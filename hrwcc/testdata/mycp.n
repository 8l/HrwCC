# gas-assembler code generated by HrwCC

.section .text
	#debug: func-def: ( int argc , char * * argv ) 
.globl main
.type main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp


	#debug: assignment: buf = malloc ( sizeof ( char ) * 10 ) ; 
	subl	$4, %esp
	pushl	$1
	popl	%ebx
	imull	$10, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 0(%esp)
	call	malloc
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	#debug: if: argc != 3 
	pushl	8(%ebp)
	popl	%ebx
	cmpl	$3, %ebx
	movl	$1, %eax
	jne	main_reltrue_1
	movl	$0, %eax
main_reltrue_1:
	testl	%eax, %eax
	jnz	main_ifbl_0
	jmp	main_elsebl_0
main_ifbl_0:
	#debug: func-call: puts ( "Please invoke by:" ) 
	subl	$4, %esp
	movl	$symtab+0, 0(%esp)
	call	puts
	addl	$4, %esp
	#debug: func-call: printf ( "   %s  infile outfile" , argv [ 0 ] ) 
	subl	$8, %esp
	movl	$symtab+18, 0(%esp)
	pushl	$0
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: exit ( - 1 ) 
	subl	$4, %esp
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 0(%esp)
	call	exit
	addl	$4, %esp
	jmp	main_endif_0

main_elsebl_0:

main_endif_0:

	#debug: assignment: infd = open ( argv [ 1 ] , 0 , 0 ) ; 
	subl	$12, %esp
	pushl	$1
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	movl	$0, 8(%esp)
	call	open
	addl	$12, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: outfd = open ( argv [ 2 ] , 64 | 1 , 6 * 8 * 8 + 4 * 8 + 4 ) ; 
	subl	$12, %esp
	pushl	$2
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	pushl	$64
	popl	%ebx
	orl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	pushl	$6
	popl	%ebx
	imull	$8, %ebx
	pushl	%ebx
	popl	%ebx
	imull	$8, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	pushl	$4
	popl	%ebx
	imull	$8, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%ebx
	addl	$4, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 8(%esp)
	call	open
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: while: 1 
main_while_2:
	movl	$1, %eax
	testl	%eax, %eax
	jz	main_endwhile_2

	#debug: assignment: read = read ( infd , buf , sizeof ( char ) * 10 ) ; 
	subl	$12, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	pushl	$1
	popl	%ebx
	imull	$10, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 8(%esp)
	call	read
	addl	$12, %esp
	movl	%eax, -12(%ebp)
	#debug: if: read == 0 
	pushl	-12(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	main_reltrue_4
	movl	$0, %eax
main_reltrue_4:
	testl	%eax, %eax
	jnz	main_ifbl_3
	jmp	main_elsebl_3
main_ifbl_3:
	jmp	main_endwhile_2
	jmp	main_endif_3

main_elsebl_3:

main_endif_3:

	#debug: func-call: write ( outfd , buf , read ) 
	subl	$12, %esp
	movl	-8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 8(%esp)
	call	write
	addl	$12, %esp
	jmp	main_while_2
main_endwhile_2:

	#debug: func-call: close ( infd ) 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	close
	addl	$4, %esp
	#debug: func-call: close ( outfd ) 
	subl	$4, %esp
	movl	-8(%ebp), %eax
	movl	%eax, 0(%esp)
	call	close
	addl	$4, %esp
	#debug: func-call: free ( buf ) 
	subl	$4, %esp
	movl	-16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	free
	addl	$4, %esp


main_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




# The symbol table 

.section .data
symtab:
	.string	"Please invoke by:"
	.string	"   %s  infile outfile"

