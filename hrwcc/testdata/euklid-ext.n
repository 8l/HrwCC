# gas-assembler code generated by HrwCC

.section .text
	#debug: func-def: ( int var1 , int var2 ) 
.globl euklidggt
.type euklidggt, @function
euklidggt:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp


	#debug: if: var1 < var2 && var2 > var1 
	pushl	8(%ebp)
	popl	%ebx
	cmpl	12(%ebp), %ebx
	movl	$1, %eax
	jl	euklidggt_reltrue_2
	movl	$0, %eax
euklidggt_reltrue_2:
	testl	%eax, %eax
	jz	euklidggt_logtermfalse_1
	pushl	12(%ebp)
	popl	%ebx
	cmpl	8(%ebp), %ebx
	movl	$1, %eax
	jg	euklidggt_reltrue_3
	movl	$0, %eax
euklidggt_reltrue_3:
	testl	%eax, %eax
	jz	euklidggt_logtermfalse_1
	movl	$1, %eax
	jmp	euklidggt_logtermtrue_1
euklidggt_logtermfalse_1:
	movl	$0, %eax
euklidggt_logtermtrue_1:
	testl	%eax, %eax
	jnz	euklidggt_ifbl_0
	jmp	euklidggt_elsebl_0
euklidggt_ifbl_0:
	#debug: assignment: div = var1 ; 
	movl	8(%ebp), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: var1 = var2 ; 
	movl	12(%ebp), %eax
	movl	%eax, 8(%ebp)
	#debug: assignment: var2 = div ; 
	movl	-4(%ebp), %eax
	movl	%eax, 12(%ebp)
	jmp	euklidggt_endif_0

euklidggt_elsebl_0:

euklidggt_endif_0:

	#debug: while: var2 > 1 || 0 
euklidggt_while_4:
	pushl	12(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jg	euklidggt_reltrue_6
	movl	$0, %eax
euklidggt_reltrue_6:
	testl	%eax, %eax
	jnz	euklidggt_logexprtrue_5
	movl	$0, %eax
	testl	%eax, %eax
	jnz	euklidggt_logexprtrue_5
	movl	$0, %eax
	jmp	euklidggt_logexprfalse_5
euklidggt_logexprtrue_5:
	movl	$1, %eax
euklidggt_logexprfalse_5:
	testl	%eax, %eax
	jz	euklidggt_endwhile_4

	#debug: assignment: div = var1 / var2 ; 
	pushl	8(%ebp)
	popl	%eax
	movl	$0, %edx
	idivl	12(%ebp)
	pushl	%eax
	popl	%eax
	movl	%eax, -4(%ebp)
	#debug: assignment: mod = var1 % var2 ; 
	pushl	8(%ebp)
	popl	%eax
	movl	$0, %edx
	idivl	12(%ebp)
	pushl	%edx
	popl	%eax
	movl	%eax, -8(%ebp)
	#debug: assignment: var1 = var2 ; 
	movl	12(%ebp), %eax
	movl	%eax, 8(%ebp)
	#debug: assignment: var2 = mod ; 
	movl	-8(%ebp), %eax
	movl	%eax, 12(%ebp)
	jmp	euklidggt_while_4
euklidggt_endwhile_4:

	#debug: return: return var1 * 1 + ( 6 % 2 ) + 2 / 4 ; 
	pushl	8(%ebp)
	popl	%ebx
	imull	$1, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	pushl	$6
	movl	$2, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%edx
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	pushl	$2
	movl	$4, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%eax
	jmp	euklidggt_ret


euklidggt_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( char ch ) 
.globl test
.type test, @function
test:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: assignment: text [ 0 ] = ch ; 
	pushl	$0
	movb	8(%ebp), %ah
	popl	%esi
	movb	%ah, -4(%ebp, %esi, 1)
	#debug: assignment: text [ 1 ] = '\n' ; 
	pushl	$1
	popl	%esi
	movb	$10, -4(%ebp, %esi, 1)
	#debug: assignment: text [ 2 ] = '\0' ; 
	pushl	$2
	popl	%esi
	movb	$0, -4(%ebp, %esi, 1)
	#debug: func-call: puts ( "hello\n" ) 
	subl	$4, %esp
	movl	$symtab+0, 0(%esp)
	call	puts
	addl	$4, %esp
	#debug: func-call: puts ( text ) 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	%eax, 0(%esp)
	call	puts
	addl	$4, %esp
	#debug: func-call: puts ( "hello\n" ) 
	subl	$4, %esp
	movl	$symtab+0, 0(%esp)
	call	puts
	addl	$4, %esp


test_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( int argc , char * * argv ) 
.globl main
.type main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$9, %esp


	#debug: assignment: ps = & second ; 
	movl	%ebp, %eax
	addl	$-1, %eax
	movl	%eax, -5(%ebp)
	#debug: assignment: g4 = & g2 . a ; 
	movl	$symtab, %eax
	addl	$7, %eax
	addl	$0, %eax
	movl	%eax, symtab+39
	#debug: assignment: g3 . b = & g2 ; 
	movl	$symtab, %eax
	addl	$23, %eax
	addl	$12, %eax
	pushl	%eax
	movl	$symtab, %eax
	addl	$7, %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: if: g4 == & g3 . b -> a 
	pushl	symtab+39
	movl	$symtab, %eax
	addl	$23, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	je	main_reltrue_8
	movl	$0, %eax
main_reltrue_8:
	testl	%eax, %eax
	jnz	main_ifbl_7
	jmp	main_elsebl_7
main_ifbl_7:
	#debug: func-call: puts ( "Pointer test ok." ) 
	subl	$4, %esp
	movl	$symtab+43, 0(%esp)
	call	puts
	addl	$4, %esp
	jmp	main_endif_7

main_elsebl_7:

main_endif_7:

	#debug: assignment: loc = 97 ; 
	movl	$97, -9(%ebp)
	#debug: func-call: test ( loc ) 
	subl	$1, %esp
	movl	-9(%ebp), %eax
	movb	%al, 0(%esp)
	call	test
	addl	$1, %esp
	#debug: assignment: g3 . b -> a . m [ 0 ] = 25 ; 
	pushl	$0
	movl	$symtab, %eax
	addl	$23, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	addl	$0, %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	pushl	%eax
	popl	%ebx
	movl	$25, (%ebx)
	#debug: assignment: second = 11 ; 
	movb	$11, -1(%ebp)
	#debug: assignment: * ps = 30 ; 
	movl	%ebp, %eax
	addl	$-5, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	movb	$30, (%ebx)
	#debug: func-call: printf ( "GCD of %d and %d is %d.\n" , g4 -> m [ 0 ] , * ps , euklidggt ( g2 . a . m [ 0 ] , * ps ) ) 
	subl	$16, %esp
	movl	$symtab+60, 0(%esp)
	pushl	$0
	movl	$symtab, %eax
	addl	$39, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-5, %eax
	movl	(%eax), %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	movl	%eax, 8(%esp)
	subl	$8, %esp
	pushl	$0
	movl	$symtab, %eax
	addl	$7, %eax
	addl	$0, %eax
	addl	$0, %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-5, %eax
	movl	(%eax), %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	movl	%eax, 4(%esp)
	call	euklidggt
	addl	$8, %esp
	movl	%eax, 12(%esp)
	call	printf
	addl	$16, %esp
	#debug: return: return euklidggt ( g3 . b -> a . m [ 0 ] , second ) ; 
	subl	$8, %esp
	pushl	$0
	movl	$symtab, %eax
	addl	$23, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	addl	$0, %eax
	popl	%esi
	imull	$4, %esi
	addl	%esi, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movb	-1(%ebp), %ah
	movsbl	%ah, %eax
	movl	%eax, 4(%esp)
	call	euklidggt
	addl	$8, %esp
	jmp	main_ret


main_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




# The symbol table 

.section .data
symtab:
	.string	"hello\n"
	#debug: global-var: mystruct2 g2 ; 
	.rept 16
		.byte 0
	.endr
	#debug: global-var: mystruct2 g3 ; 
	.rept 16
		.byte 0
	.endr
	#debug: global-var: mystruct * g4 ; 
	.long 0
	.string	"Pointer test ok."
	.string	"GCD of %d and %d is %d.\n"

