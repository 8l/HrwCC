# gas-assembler code generated by HrwCC

.section .text
	#debug: func-def: ( codegen * cg , char * errstr , token name ) 
.globl codegen_reportError
.type codegen_reportError, @function
codegen_reportError:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: assignment: cg -> cnterrors = cg -> cnterrors + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: filename = preproc_getFilename ( cg -> parse -> scan -> pp , name . pos_fileid ) ; 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	addl	$17, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	preproc_getFilename
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: printf ( "CODEGEN_ERROR: %d, " , cg -> parse -> curr -> pos_col ) 
	subl	$8, %esp
	movl	$symtab+0, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$16, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( "%d, " , cg -> parse -> curr -> pos_line ) 
	subl	$8, %esp
	movl	$symtab+20, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$16, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: if: filename 
	movl	-4(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_reportError_ifbl_0
	jmp	codegen_reportError_elsebl_0
codegen_reportError_ifbl_0:
	#debug: func-call: printf ( "%s:\n" , filename ) 
	subl	$8, %esp
	movl	$symtab+25, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	jmp	codegen_reportError_endif_0

codegen_reportError_elsebl_0:

	#debug: func-call: printf ( "[ERR filename] (%p)\n" , filename ) 
	subl	$8, %esp
	movl	$symtab+30, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
codegen_reportError_endif_0:

	#debug: func-call: printf ( "\tToken is '%s' ::   " , name . content ) 
	subl	$8, %esp
	movl	$symtab+51, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( "%s\n" , errstr ) 
	subl	$8, %esp
	movl	$symtab+72, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp


codegen_reportError_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * errstr , token name ) 
.globl codegen_reportWarning
.type codegen_reportWarning, @function
codegen_reportWarning:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: assignment: cg -> cntwarnings = cg -> cntwarnings + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: filename = preproc_getFilename ( cg -> parse -> scan -> pp , name . pos_fileid ) ; 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	addl	$17, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	preproc_getFilename
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: printf ( "CODEGEN_WARNING: %s" , errstr ) 
	subl	$8, %esp
	movl	$symtab+76, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( " Token is %d" , name . type ) 
	subl	$8, %esp
	movl	$symtab+96, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( ", %s" , name . content ) 
	subl	$8, %esp
	movl	$symtab+109, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( " @ %d" , name . pos_line ) 
	subl	$8, %esp
	movl	$symtab+114, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: printf ( ",%d, " , name . pos_col ) 
	subl	$8, %esp
	movl	$symtab+120, 0(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: if: filename 
	movl	-4(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_reportWarning_ifbl_1
	jmp	codegen_reportWarning_elsebl_1
codegen_reportWarning_ifbl_1:
	#debug: func-call: printf ( "%s\n" , filename ) 
	subl	$8, %esp
	movl	$symtab+72, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	jmp	codegen_reportWarning_endif_1

codegen_reportWarning_elsebl_1:

	#debug: func-call: puts ( "[ERR filename]\n" ) 
	subl	$4, %esp
	movl	$symtab+126, 0(%esp)
	call	puts
	addl	$4, %esp
codegen_reportWarning_endif_1:



codegen_reportWarning_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * text ) 
.globl codegen_emit
.type codegen_emit, @function
codegen_emit:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: if: cg -> fd < 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_emit_reltrue_3
	movl	$0, %eax
codegen_emit_reltrue_3:
	testl	%eax, %eax
	jnz	codegen_emit_ifbl_2
	jmp	codegen_emit_elsebl_2
codegen_emit_ifbl_2:
	#debug: return: return ; 
	jmp	codegen_emit_ret
	jmp	codegen_emit_endif_2

codegen_emit_elsebl_2:

codegen_emit_endif_2:

	#debug: assignment: res = write ( cg -> fd , text , strlen ( text ) ) ; 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	strlen
	addl	$4, %esp
	movl	%eax, 8(%esp)
	call	write
	addl	$12, %esp
	movl	%eax, -4(%ebp)
	#debug: if: res < 0 
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_emit_reltrue_5
	movl	$0, %eax
codegen_emit_reltrue_5:
	testl	%eax, %eax
	jnz	codegen_emit_ifbl_4
	jmp	codegen_emit_elsebl_4
codegen_emit_ifbl_4:
	#debug: func-call: puts ( "CODEGEN_ERROR: Error emitting code to file!" ) 
	subl	$4, %esp
	movl	$symtab+142, 0(%esp)
	call	puts
	addl	$4, %esp
	#debug: assignment: cg -> cnterrors = cg -> cnterrors + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: cg -> fd = - 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	pushl	%eax
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	jmp	codegen_emit_endif_4

codegen_emit_elsebl_4:

codegen_emit_endif_4:



codegen_emit_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_emitTree
.type codegen_emitTree, @function
codegen_emitTree:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp


	#debug: if: tree == 0 
	pushl	12(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_emitTree_reltrue_7
	movl	$0, %eax
codegen_emitTree_reltrue_7:
	testl	%eax, %eax
	jnz	codegen_emitTree_ifbl_6
	jmp	codegen_emitTree_elsebl_6
codegen_emitTree_ifbl_6:
	#debug: return: return ; 
	jmp	codegen_emitTree_ret
	jmp	codegen_emitTree_endif_6

codegen_emitTree_elsebl_6:

codegen_emitTree_endif_6:

	#debug: if: tree -> tok . type != 0 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_emitTree_reltrue_9
	movl	$0, %eax
codegen_emitTree_reltrue_9:
	testl	%eax, %eax
	jnz	codegen_emitTree_ifbl_8
	jmp	codegen_emitTree_elsebl_8
codegen_emitTree_ifbl_8:
	#debug: func-call: codegen_emit ( cg , tree -> tok . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , " " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+186, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_emitTree_endif_8

codegen_emitTree_elsebl_8:

codegen_emitTree_endif_8:

	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: idx = 0 ; 
	movl	$0, -4(%ebp)
	#debug: while: idx < cnt 
codegen_emitTree_while_10:
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	-8(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_emitTree_reltrue_11
	movl	$0, %eax
codegen_emitTree_reltrue_11:
	testl	%eax, %eax
	jz	codegen_emitTree_endwhile_10

	#debug: func-call: codegen_emitTree ( cg , syntax_GetChild ( tree , idx ) ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	call	codegen_emitTree
	addl	$8, %esp
	#debug: assignment: idx = idx + 1 ; 
	pushl	-4(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -4(%ebp)
	jmp	codegen_emitTree_while_10
codegen_emitTree_endwhile_10:



codegen_emitTree_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * text , syntaxTreeNode * tree ) 
.globl codegen_debug
.type codegen_debug, @function
codegen_debug:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: if: ! cg -> emitdebug 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$12, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_debug_logfactfalse_13
	movl	$0, %eax
codegen_debug_logfactfalse_13:
	testl	%eax, %eax
	jnz	codegen_debug_ifbl_12
	jmp	codegen_debug_elsebl_12
codegen_debug_ifbl_12:
	#debug: return: return ; 
	jmp	codegen_debug_ret
	jmp	codegen_debug_endif_12

codegen_debug_elsebl_12:

codegen_debug_endif_12:

	#debug: func-call: codegen_emit ( cg , "\t#debug: " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+188, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , text ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emitTree ( cg , tree ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emitTree
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp


codegen_debug_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , int fd , parser * parser ) 
.globl codegen_CreateCodeGen
.type codegen_CreateCodeGen, @function
codegen_CreateCodeGen:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: assignment: cg -> cnterrors = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: cg -> cntwarnings = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: cg -> fd = fd ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	pushl	%eax
	movl	12(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: cg -> parse = parser ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: cg -> emitdebug = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$12, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: cg -> enOptFastassign = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$16, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: cg -> cntBlocks = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: cg -> currWhileNr = - 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$28, %eax
	pushl	%eax
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: func-call: strcpy ( cg -> currFuncName . content , "" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+200, 4(%esp)
	call	strcpy
	addl	$8, %esp


codegen_CreateCodeGen_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * result ) 
.globl codegen_EmitAvoidConstant
.type codegen_EmitAvoidConstant, @function
codegen_EmitAvoidConstant:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: if: result [ 0 ] == '$' 
	pushl	$0
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$36, %ebx
	movl	$1, %eax
	je	codegen_EmitAvoidConstant_reltrue_15
	movl	$0, %eax
codegen_EmitAvoidConstant_reltrue_15:
	testl	%eax, %eax
	jnz	codegen_EmitAvoidConstant_ifbl_14
	jmp	codegen_EmitAvoidConstant_elsebl_14
codegen_EmitAvoidConstant_ifbl_14:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitAvoidConstant_endif_14

codegen_EmitAvoidConstant_elsebl_14:

codegen_EmitAvoidConstant_endif_14:



codegen_EmitAvoidConstant_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * result , syntaxTreeNode * type ) 
.globl codegen_EmitAvoidIndirect
.type codegen_EmitAvoidIndirect, @function
codegen_EmitAvoidIndirect:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: if: result [ 0 ] != '%' && result [ 0 ] != '$' 
	pushl	$0
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$37, %ebx
	movl	$1, %eax
	jne	codegen_EmitAvoidIndirect_reltrue_18
	movl	$0, %eax
codegen_EmitAvoidIndirect_reltrue_18:
	testl	%eax, %eax
	jz	codegen_EmitAvoidIndirect_logtermfalse_17
	pushl	$0
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$36, %ebx
	movl	$1, %eax
	jne	codegen_EmitAvoidIndirect_reltrue_19
	movl	$0, %eax
codegen_EmitAvoidIndirect_reltrue_19:
	testl	%eax, %eax
	jz	codegen_EmitAvoidIndirect_logtermfalse_17
	movl	$1, %eax
	jmp	codegen_EmitAvoidIndirect_logtermtrue_17
codegen_EmitAvoidIndirect_logtermfalse_17:
	movl	$0, %eax
codegen_EmitAvoidIndirect_logtermtrue_17:
	testl	%eax, %eax
	jnz	codegen_EmitAvoidIndirect_ifbl_16
	jmp	codegen_EmitAvoidIndirect_elsebl_16
codegen_EmitAvoidIndirect_ifbl_16:
	#debug: if: type_IsByteSized ( type ) 
	subl	$4, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitAvoidIndirect_ifbl_20
	jmp	codegen_EmitAvoidIndirect_elsebl_20
codegen_EmitAvoidIndirect_ifbl_20:
	#debug: func-call: codegen_emit ( cg , "\tmovb\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+221, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitAvoidIndirect_endif_20

codegen_EmitAvoidIndirect_elsebl_20:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
codegen_EmitAvoidIndirect_endif_20:

	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: type_IsByteSized ( type ) 
	subl	$4, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitAvoidIndirect_ifbl_21
	jmp	codegen_EmitAvoidIndirect_elsebl_21
codegen_EmitAvoidIndirect_ifbl_21:
	#debug: func-call: codegen_emit ( cg , ", %ah\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+228, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%ah" ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+235, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitAvoidIndirect_endif_21

codegen_EmitAvoidIndirect_elsebl_21:

	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitAvoidIndirect_endif_21:

	jmp	codegen_EmitAvoidIndirect_endif_16

codegen_EmitAvoidIndirect_elsebl_16:

codegen_EmitAvoidIndirect_endif_16:



codegen_EmitAvoidIndirect_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg ) 
.globl codegen_EmitProgrammStart
.type codegen_EmitProgrammStart, @function
codegen_EmitProgrammStart:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: func-call: codegen_emit ( cg , "# gas-assembler code generated by HrwCC\n\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+239, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ".section .text\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+281, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitProgrammStart_ret


codegen_EmitProgrammStart_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg ) 
.globl codegen_EmitSymboltable
.type codegen_EmitSymboltable, @function
codegen_EmitSymboltable:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$180, %esp


	#debug: func-call: codegen_emit ( cg , "# The symbol table \n\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+297, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ".section .data\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+319, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "symtab:\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+335, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = 0 ; 
	movl	$0, -164(%ebp)
	#debug: func-call: symbol_ClearNonGlobalVariables ( cg -> parse -> symTable ) 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	symbol_ClearNonGlobalVariables
	addl	$4, %esp
	#debug: assignment: cnt = symbol_CountEntries ( cg -> parse -> symTable ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	symbol_CountEntries
	addl	$4, %esp
	movl	%eax, -168(%ebp)
	#debug: while: idx < cnt 
codegen_EmitSymboltable_while_22:
	pushl	-164(%ebp)
	popl	%ebx
	cmpl	-168(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitSymboltable_reltrue_23
	movl	$0, %eax
codegen_EmitSymboltable_reltrue_23:
	testl	%eax, %eax
	jz	codegen_EmitSymboltable_endwhile_22

	#debug: assignment: node = symbol_GetEntry ( cg -> parse -> symTable , idx ) ; 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-164(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetEntry
	addl	$8, %esp
	movl	%eax, -172(%ebp)
	#debug: assignment: tree = node -> structure ; 
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, -176(%ebp)
	#debug: if: node -> type == 7 
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$7, %ebx
	movl	$1, %eax
	je	codegen_EmitSymboltable_reltrue_25
	movl	$0, %eax
codegen_EmitSymboltable_reltrue_25:
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_ifbl_24
	jmp	codegen_EmitSymboltable_elsebl_24
codegen_EmitSymboltable_ifbl_24:
	#debug: func-call: codegen_emit ( cg , "\t.string\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+344, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tree -> tok . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitSymboltable_endif_24

codegen_EmitSymboltable_elsebl_24:

codegen_EmitSymboltable_endif_24:

	#debug: if: node -> type == 5 
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$5, %ebx
	movl	$1, %eax
	je	codegen_EmitSymboltable_reltrue_27
	movl	$0, %eax
codegen_EmitSymboltable_reltrue_27:
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_ifbl_26
	jmp	codegen_EmitSymboltable_elsebl_26
codegen_EmitSymboltable_ifbl_26:
	#debug: assignment: type = type_CreateType ( tree ) ; 
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	movl	%eax, -180(%ebp)
	#debug: func-call: codegen_debug ( cg , "global-var: " , tree ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+354, 4(%esp)
	movl	-176(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: if: type_IsAArrayVar ( tree ) || type_IsAStructVar ( tree ) 
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_logexprtrue_29
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructVar
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_logexprtrue_29
	movl	$0, %eax
	jmp	codegen_EmitSymboltable_logexprfalse_29
codegen_EmitSymboltable_logexprtrue_29:
	movl	$1, %eax
codegen_EmitSymboltable_logexprfalse_29:
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_ifbl_28
	jmp	codegen_EmitSymboltable_elsebl_28
codegen_EmitSymboltable_ifbl_28:
	#debug: func-call: sprintf ( tmp , "\t.rept %d\n" , symbol_Sizeof_Symbol ( cg -> parse -> symTable , node ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+367, 4(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-172(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_Symbol
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , tmp ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\t\t.byte 0\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+378, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\t.endr\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+389, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitSymboltable_endif_28

codegen_EmitSymboltable_elsebl_28:

	#debug: if: type_IsLongSized ( type ) 
	subl	$4, %esp
	movl	-180(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_ifbl_30
	jmp	codegen_EmitSymboltable_elsebl_30
codegen_EmitSymboltable_ifbl_30:
	#debug: func-call: codegen_emit ( cg , "\t.long 0\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+397, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitSymboltable_endif_30

codegen_EmitSymboltable_elsebl_30:

	#debug: if: type_IsByteSized ( type ) 
	subl	$4, %esp
	movl	-180(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitSymboltable_ifbl_31
	jmp	codegen_EmitSymboltable_elsebl_31
codegen_EmitSymboltable_ifbl_31:
	#debug: func-call: codegen_emit ( cg , "\t.byte 0\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+407, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitSymboltable_endif_31

codegen_EmitSymboltable_elsebl_31:

	#debug: func-call: syntax_printTree ( tree ) 
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_printTree
	addl	$4, %esp
	#debug: func-call: printf ( "struct: %d\n" , type_IsAStructVar ( tree ) ) 
	subl	$8, %esp
	movl	$symtab+417, 0(%esp)
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructVar
	addl	$4, %esp
	movl	%eax, 4(%esp)
	call	printf
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tunknown type of symtab-entry!\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+429, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
codegen_EmitSymboltable_endif_31:

codegen_EmitSymboltable_endif_30:

codegen_EmitSymboltable_endif_28:

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-180(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	jmp	codegen_EmitSymboltable_endif_26

codegen_EmitSymboltable_elsebl_26:

codegen_EmitSymboltable_endif_26:

	#debug: assignment: idx = idx + 1 ; 
	pushl	-164(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -164(%ebp)
	jmp	codegen_EmitSymboltable_while_22
codegen_EmitSymboltable_endwhile_22:

	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitSymboltable_ret


codegen_EmitSymboltable_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg ) 
.globl codegen_EmitBeginFunction
.type codegen_EmitBeginFunction, @function
codegen_EmitBeginFunction:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$168, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: node = symbol_FindFunction ( symtab , cg -> currFuncName ) ; 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindFunction
	addl	$148, %esp
	movl	%eax, -8(%ebp)
	#debug: if: node != 0 
	pushl	-8(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitBeginFunction_reltrue_33
	movl	$0, %eax
codegen_EmitBeginFunction_reltrue_33:
	testl	%eax, %eax
	jnz	codegen_EmitBeginFunction_ifbl_32
	jmp	codegen_EmitBeginFunction_elsebl_32
codegen_EmitBeginFunction_ifbl_32:
	#debug: func-call: codegen_debug ( cg , "func-def: " , syntax_GetChild ( node -> structure , 1 ) ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+461, 4(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	jmp	codegen_EmitBeginFunction_endif_32

codegen_EmitBeginFunction_elsebl_32:

codegen_EmitBeginFunction_endif_32:

	#debug: func-call: codegen_emit ( cg , ".globl " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+472, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , cg -> currFuncName . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ".type " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+480, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , cg -> currFuncName . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", @function\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+487, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , cg -> currFuncName . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ":\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+500, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tpushl\t%ebp\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+503, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t%esp, %ebp\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+516, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( buffer , "\tsubl\t$%d, %%esp\n" , symbol_GetLocalVarBlockSize ( symtab ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+534, 4(%esp)
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	symbol_GetLocalVarBlockSize
	addl	$4, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , buffer ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+552, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitBeginFunction_ret


codegen_EmitBeginFunction_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg ) 
.globl codegen_EmitEndFunction
.type codegen_EmitEndFunction, @function
codegen_EmitEndFunction:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: func-call: codegen_emit ( cg , "\n\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+552, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , cg -> currFuncName . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "_ret:\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+555, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t%ebp, %esp\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+562, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tpopl\t%ebp\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+580, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tret\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+592, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n\n\n\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+598, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitEndFunction_ret


codegen_EmitEndFunction_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , int * blocknr ) 
.globl codegen_EmitBeginIf
.type codegen_EmitBeginIf, @function
codegen_EmitBeginIf:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$328, %esp


	#debug: assignment: * blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: func-call: codegen_debug ( cg , "if: " , syntax_GetChild ( tree , 2 ) ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+603, 4(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 2 ) , resbuf ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -324(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -328(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , resbuf , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -324(%ebp)
	#debug: func-call: codegen_EmitAvoidConstant ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , resbuf , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: codegen_emit ( cg , "\ttestl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+608, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjnz\t%s_ifbl_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+619, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , * blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_elsebl_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+637, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , * blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_ifbl_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+657, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , * blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitBeginIf_ret


codegen_EmitBeginIf_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , int blocknr ) 
.globl codegen_EmitElseIf
.type codegen_EmitElseIf, @function
codegen_EmitElseIf:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$320, %esp


	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_endif_%%d\n\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+671, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_elsebl_%%d:\n\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+691, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitElseIf_ret


codegen_EmitElseIf_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , int blocknr ) 
.globl codegen_EmitEndIf
.type codegen_EmitEndIf, @function
codegen_EmitEndIf:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$320, %esp


	#debug: func-call: sprintf ( tmp , "%s_endif_%%d:\n\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+708, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitEndIf_ret


codegen_EmitEndIf_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , int * blocknr ) 
.globl codegen_EmitBeginWhile
.type codegen_EmitBeginWhile, @function
codegen_EmitBeginWhile:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$328, %esp


	#debug: assignment: * blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: func-call: codegen_debug ( cg , "while: " , syntax_GetChild ( tree , 2 ) ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+724, 4(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: func-call: sprintf ( tmp , "%s_while_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+732, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , * blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 2 ) , resbuf ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -324(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -328(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , resbuf , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -324(%ebp)
	#debug: func-call: codegen_EmitAvoidConstant ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , resbuf , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: codegen_emit ( cg , "\ttestl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+608, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjz\t%s_endwhile_%%d\n\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+747, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , * blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitBeginWhile_ret


codegen_EmitBeginWhile_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , int blocknr ) 
.globl codegen_EmitEndWhile
.type codegen_EmitEndWhile, @function
codegen_EmitEndWhile:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$320, %esp


	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_while_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+769, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_endwhile_%%d:\n\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+788, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , blocknr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitEndWhile_ret


codegen_EmitEndWhile_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_EmitBreak
.type codegen_EmitBreak, @function
codegen_EmitBreak:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$324, %esp


	#debug: if: cg -> currWhileNr < 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$28, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_EmitBreak_reltrue_35
	movl	$0, %eax
codegen_EmitBreak_reltrue_35:
	testl	%eax, %eax
	jnz	codegen_EmitBreak_ifbl_34
	jmp	codegen_EmitBreak_elsebl_34
codegen_EmitBreak_ifbl_34:
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -324(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Detected a break-statement which is not bounded by a while." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+807, 4(%esp)
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitBreak_ret
	jmp	codegen_EmitBreak_endif_34

codegen_EmitBreak_elsebl_34:

codegen_EmitBreak_endif_34:

	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_endwhile_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+867, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , cg -> currWhileNr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$28, %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitBreak_ret


codegen_EmitBreak_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_EmitContinue
.type codegen_EmitContinue, @function
codegen_EmitContinue:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$324, %esp


	#debug: if: cg -> currWhileNr < 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$28, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_EmitContinue_reltrue_37
	movl	$0, %eax
codegen_EmitContinue_reltrue_37:
	testl	%eax, %eax
	jnz	codegen_EmitContinue_ifbl_36
	jmp	codegen_EmitContinue_elsebl_36
codegen_EmitContinue_ifbl_36:
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -324(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Detected a continue-statement which is not bounded by a while." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+889, 4(%esp)
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitContinue_ret
	jmp	codegen_EmitContinue_endif_36

codegen_EmitContinue_elsebl_36:

codegen_EmitContinue_endif_36:

	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_while_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+769, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( resbuf , tmp , cg -> currWhileNr ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$28, %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitContinue_ret


codegen_EmitContinue_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_EmitReturn
.type codegen_EmitReturn, @function
codegen_EmitReturn:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$180, %esp


	#debug: func-call: codegen_debug ( cg , "return: " , tree ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+952, 4(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: assignment: funcNode = symbol_FindFunction ( cg -> parse -> symTable , cg -> currFuncName ) ; 
	subl	$148, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindFunction
	addl	$148, %esp
	movl	%eax, -168(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -180(%ebp)
	#debug: if: funcNode == 0 
	pushl	-168(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitReturn_reltrue_39
	movl	$0, %eax
codegen_EmitReturn_reltrue_39:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_38
	jmp	codegen_EmitReturn_elsebl_38
codegen_EmitReturn_ifbl_38:
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitReturn_ret
	jmp	codegen_EmitReturn_endif_38

codegen_EmitReturn_elsebl_38:

codegen_EmitReturn_endif_38:

	#debug: if: syntax_CountChilds ( tree ) > 2 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$2, %ebx
	movl	$1, %eax
	jg	codegen_EmitReturn_reltrue_41
	movl	$0, %eax
codegen_EmitReturn_reltrue_41:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_40
	jmp	codegen_EmitReturn_elsebl_40
codegen_EmitReturn_ifbl_40:
	#debug: assignment: retpresent = 1 ; 
	movl	$1, -164(%ebp)
	jmp	codegen_EmitReturn_endif_40

codegen_EmitReturn_elsebl_40:

	#debug: assignment: retpresent = 0 ; 
	movl	$0, -164(%ebp)
codegen_EmitReturn_endif_40:

	#debug: if: syntax_CountChilds ( tree ) > 2 && ! symbol_IsReturnTypeVoid ( cg -> parse -> symTable , funcNode -> structure ) 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$2, %ebx
	movl	$1, %eax
	jg	codegen_EmitReturn_reltrue_44
	movl	$0, %eax
codegen_EmitReturn_reltrue_44:
	testl	%eax, %eax
	jz	codegen_EmitReturn_logtermfalse_43
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	symbol_IsReturnTypeVoid
	addl	$8, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitReturn_logfactfalse_45
	movl	$0, %eax
codegen_EmitReturn_logfactfalse_45:
	testl	%eax, %eax
	jz	codegen_EmitReturn_logtermfalse_43
	movl	$1, %eax
	jmp	codegen_EmitReturn_logtermtrue_43
codegen_EmitReturn_logtermfalse_43:
	movl	$0, %eax
codegen_EmitReturn_logtermtrue_43:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_42
	jmp	codegen_EmitReturn_elsebl_42
codegen_EmitReturn_ifbl_42:
	#debug: assignment: retTree = funcNode -> structure ; 
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, -172(%ebp)
	#debug: assignment: retTree = symbol_GetReturnType ( cg -> parse -> symTable , retTree ) ; 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-172(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetReturnType
	addl	$8, %esp
	movl	%eax, -172(%ebp)
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 1 ) , resbuf ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -176(%ebp)
	#debug: if: type_IsAIntType ( retTree ) || type_IsAPointerType ( retTree ) 
	subl	$4, %esp
	movl	-172(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAIntType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitReturn_logexprtrue_47
	subl	$4, %esp
	movl	-172(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitReturn_logexprtrue_47
	movl	$0, %eax
	jmp	codegen_EmitReturn_logexprfalse_47
codegen_EmitReturn_logexprtrue_47:
	movl	$1, %eax
codegen_EmitReturn_logexprfalse_47:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_46
	jmp	codegen_EmitReturn_elsebl_46
codegen_EmitReturn_ifbl_46:
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , resbuf , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-176(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -176(%ebp)
	jmp	codegen_EmitReturn_endif_46

codegen_EmitReturn_elsebl_46:

	#debug: if: type_IsACharType ( retTree ) 
	subl	$4, %esp
	movl	-172(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsACharType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_48
	jmp	codegen_EmitReturn_elsebl_48
codegen_EmitReturn_ifbl_48:
	#debug: assignment: type = codegen_CastToChar ( cg , subtree -> tok , resbuf , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-176(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -176(%ebp)
	jmp	codegen_EmitReturn_endif_48

codegen_EmitReturn_elsebl_48:

	#debug: func-call: codegen_reportError ( cg , "Return-type of struct-instance is not supported.\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+961, 4(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_EmitReturn_endif_48:

codegen_EmitReturn_endif_46:

	#debug: if: strcmp ( resbuf , "%eax" ) != 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitReturn_reltrue_50
	movl	$0, %eax
codegen_EmitReturn_reltrue_50:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_49
	jmp	codegen_EmitReturn_elsebl_49
codegen_EmitReturn_ifbl_49:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitReturn_endif_49

codegen_EmitReturn_elsebl_49:

codegen_EmitReturn_endif_49:

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-176(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	jmp	codegen_EmitReturn_endif_42

codegen_EmitReturn_elsebl_42:

codegen_EmitReturn_endif_42:

	#debug: func-call: sprintf ( resbuf , "\tjmp\t%s_ret\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1011, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , resbuf ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: symbol_IsReturnTypeVoid ( cg -> parse -> symTable , funcNode -> structure ) == retpresent 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	symbol_IsReturnTypeVoid
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	-164(%ebp), %ebx
	movl	$1, %eax
	je	codegen_EmitReturn_reltrue_52
	movl	$0, %eax
codegen_EmitReturn_reltrue_52:
	testl	%eax, %eax
	jnz	codegen_EmitReturn_ifbl_51
	jmp	codegen_EmitReturn_elsebl_51
codegen_EmitReturn_ifbl_51:
	#debug: func-call: codegen_reportError ( cg , "Non-void return-typed functions need return value!" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1024, 4(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitReturn_ret
	jmp	codegen_EmitReturn_endif_51

codegen_EmitReturn_elsebl_51:

codegen_EmitReturn_endif_51:

	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitReturn_ret


codegen_EmitReturn_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitFuncCallExpr
.type codegen_EmitFuncCallExpr, @function
codegen_EmitFuncCallExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: func-call: codegen_debug ( cg , "func-call: " , tree ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1075, 4(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: assignment: restype = codegen_EmitFuncCall ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitFuncCall
	addl	$12, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( restype ) 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitFuncCallExpr_ret


codegen_EmitFuncCallExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * target , syntaxTreeNode * source , token errtok ) 
.globl codegen_CheckCasting
.type codegen_CheckCasting, @function
codegen_CheckCasting:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: if: type_IsAPointerType ( target ) && type_IsAPointerType ( source ) 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_54
	subl	$4, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_54
	movl	$1, %eax
	jmp	codegen_CheckCasting_logtermtrue_54
codegen_CheckCasting_logtermfalse_54:
	movl	$0, %eax
codegen_CheckCasting_logtermtrue_54:
	testl	%eax, %eax
	jnz	codegen_CheckCasting_ifbl_53
	jmp	codegen_CheckCasting_elsebl_53
codegen_CheckCasting_ifbl_53:
	#debug: assignment: subtree = codegen_CreateVoidPntType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateVoidPntType
	addl	$0, %esp
	movl	%eax, -4(%ebp)
	#debug: if: source != 0 && ! syntax_EqualTrees ( subtree , target ) && ! syntax_EqualTrees ( subtree , source ) && ! syntax_EqualTrees ( source , target ) 
	pushl	16(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_CheckCasting_reltrue_57
	movl	$0, %eax
codegen_CheckCasting_reltrue_57:
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_56
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_EqualTrees
	addl	$8, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_CheckCasting_logfactfalse_58
	movl	$0, %eax
codegen_CheckCasting_logfactfalse_58:
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_56
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_EqualTrees
	addl	$8, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_CheckCasting_logfactfalse_59
	movl	$0, %eax
codegen_CheckCasting_logfactfalse_59:
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_56
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_EqualTrees
	addl	$8, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_CheckCasting_logfactfalse_60
	movl	$0, %eax
codegen_CheckCasting_logfactfalse_60:
	testl	%eax, %eax
	jz	codegen_CheckCasting_logtermfalse_56
	movl	$1, %eax
	jmp	codegen_CheckCasting_logtermtrue_56
codegen_CheckCasting_logtermfalse_56:
	movl	$0, %eax
codegen_CheckCasting_logtermtrue_56:
	testl	%eax, %eax
	jnz	codegen_CheckCasting_ifbl_55
	jmp	codegen_CheckCasting_elsebl_55
codegen_CheckCasting_ifbl_55:
	#debug: func-call: codegen_reportWarning ( cg , "Pointer types must be equal or one of both is void* typed." , errtok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1087, 4(%esp)
	movl	%ebp, %eax
	addl	$20, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportWarning
	addl	$152, %esp
	jmp	codegen_CheckCasting_endif_55

codegen_CheckCasting_elsebl_55:

codegen_CheckCasting_endif_55:

	#debug: func-call: syntax_FreeSyntaxTree ( subtree ) 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_CheckCasting_ret
	jmp	codegen_CheckCasting_endif_53

codegen_CheckCasting_elsebl_53:

codegen_CheckCasting_endif_53:

	#debug: if: type_IsAStructType ( target ) || type_IsAStructType ( source ) 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CheckCasting_logexprtrue_62
	subl	$4, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CheckCasting_logexprtrue_62
	movl	$0, %eax
	jmp	codegen_CheckCasting_logexprfalse_62
codegen_CheckCasting_logexprtrue_62:
	movl	$1, %eax
codegen_CheckCasting_logexprfalse_62:
	testl	%eax, %eax
	jnz	codegen_CheckCasting_ifbl_61
	jmp	codegen_CheckCasting_elsebl_61
codegen_CheckCasting_ifbl_61:
	#debug: if: ! syntax_EqualTrees ( target , source ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_EqualTrees
	addl	$8, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_CheckCasting_logfactfalse_64
	movl	$0, %eax
codegen_CheckCasting_logfactfalse_64:
	testl	%eax, %eax
	jnz	codegen_CheckCasting_ifbl_63
	jmp	codegen_CheckCasting_elsebl_63
codegen_CheckCasting_ifbl_63:
	#debug: func-call: codegen_reportError ( cg , "Casting between struct-instances not allowed." , errtok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1146, 4(%esp)
	movl	%ebp, %eax
	addl	$20, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	jmp	codegen_CheckCasting_endif_63

codegen_CheckCasting_elsebl_63:

codegen_CheckCasting_endif_63:

	jmp	codegen_CheckCasting_endif_61

codegen_CheckCasting_elsebl_61:

codegen_CheckCasting_endif_61:

	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_CheckCasting_ret


codegen_CheckCasting_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , char * destaddr , char * srcaddr , int size ) 
.globl codegen_EmitCopyJunk
.type codegen_EmitCopyJunk, @function
codegen_EmitCopyJunk:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$172, %esp


	#debug: assignment: cntlong = size / 4 ; 
	pushl	20(%ebp)
	movl	$4, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	movl	%eax, -4(%ebp)
	#debug: assignment: cntbyte = size % 4 ; 
	pushl	20(%ebp)
	movl	$4, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%edx
	popl	%eax
	movl	%eax, -8(%ebp)
	#debug: if: destaddr [ 0 ] != '%' 
	pushl	$0
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$37, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_66
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_66:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_65
	jmp	codegen_EmitCopyJunk_elsebl_65
codegen_EmitCopyJunk_ifbl_65:
	#debug: if: strcmp ( srcaddr , "%eax" ) == 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitCopyJunk_reltrue_68
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_68:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_67
	jmp	codegen_EmitCopyJunk_elsebl_67
codegen_EmitCopyJunk_ifbl_67:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %ebx\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1192, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( destaddr , "%ebx" ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitCopyJunk_endif_67

codegen_EmitCopyJunk_elsebl_67:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( destaddr , "%eax" ) 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitCopyJunk_endif_67:

	jmp	codegen_EmitCopyJunk_endif_65

codegen_EmitCopyJunk_elsebl_65:

codegen_EmitCopyJunk_endif_65:

	#debug: if: srcaddr [ 0 ] != '%' 
	pushl	$0
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$37, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_70
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_70:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_69
	jmp	codegen_EmitCopyJunk_elsebl_69
codegen_EmitCopyJunk_ifbl_69:
	#debug: if: strcmp ( destaddr , "%eax" ) == 0 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitCopyJunk_reltrue_72
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_72:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_71
	jmp	codegen_EmitCopyJunk_elsebl_71
codegen_EmitCopyJunk_ifbl_71:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %ebx\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1192, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( srcaddr , "%ebx" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitCopyJunk_endif_71

codegen_EmitCopyJunk_elsebl_71:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( srcaddr , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitCopyJunk_endif_71:

	jmp	codegen_EmitCopyJunk_endif_69

codegen_EmitCopyJunk_elsebl_69:

codegen_EmitCopyJunk_endif_69:

	#debug: if: strcmp ( srcaddr , "%eax" ) != 0 && strcmp ( destaddr , "%eax" ) != 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_75
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_75:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_logtermfalse_74
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_76
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_76:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_logtermfalse_74
	movl	$1, %eax
	jmp	codegen_EmitCopyJunk_logtermtrue_74
codegen_EmitCopyJunk_logtermfalse_74:
	movl	$0, %eax
codegen_EmitCopyJunk_logtermtrue_74:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_73
	jmp	codegen_EmitCopyJunk_elsebl_73
codegen_EmitCopyJunk_ifbl_73:
	#debug: func-call: strcpy ( tmpreg , "%eax" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitCopyJunk_endif_73

codegen_EmitCopyJunk_elsebl_73:

	#debug: if: strcmp ( srcaddr , "%ebx" ) != 0 && strcmp ( destaddr , "%ebx" ) != 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_79
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_79:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_logtermfalse_78
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitCopyJunk_reltrue_80
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_80:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_logtermfalse_78
	movl	$1, %eax
	jmp	codegen_EmitCopyJunk_logtermtrue_78
codegen_EmitCopyJunk_logtermfalse_78:
	movl	$0, %eax
codegen_EmitCopyJunk_logtermtrue_78:
	testl	%eax, %eax
	jnz	codegen_EmitCopyJunk_ifbl_77
	jmp	codegen_EmitCopyJunk_elsebl_77
codegen_EmitCopyJunk_ifbl_77:
	#debug: func-call: strcpy ( tmpreg , "%ebx" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitCopyJunk_endif_77

codegen_EmitCopyJunk_elsebl_77:

	#debug: func-call: strcpy ( tmpreg , "%ecx" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1205, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitCopyJunk_endif_77:

codegen_EmitCopyJunk_endif_73:

	#debug: assignment: idx = 0 ; 
	movl	$0, -12(%ebp)
	#debug: while: idx < cntlong 
codegen_EmitCopyJunk_while_81:
	pushl	-12(%ebp)
	popl	%ebx
	cmpl	-4(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitCopyJunk_reltrue_82
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_82:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_endwhile_81

	#debug: func-call: codegen_emit ( cg , "\tmovl\t(" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1210, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "), " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1218, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tmpreg ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tmpreg ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", (" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1222, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ")\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1226, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\taddl\t$4, " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1229, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\taddl\t$4, " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1229, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 1 ; 
	pushl	-12(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	codegen_EmitCopyJunk_while_81
codegen_EmitCopyJunk_endwhile_81:

	#debug: assignment: tmpreg [ 1 ] = tmpreg [ 2 ] ; 
	pushl	$1
	pushl	$2
	movl	%ebp, %eax
	addl	$-172, %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	popl	%esi
	movb	%al, -172(%ebp, %esi, 1)
	#debug: assignment: tmpreg [ 2 ] = 'l' ; 
	pushl	$2
	popl	%esi
	movb	$108, -172(%ebp, %esi, 1)
	#debug: assignment: tmpreg [ 3 ] = '\0' ; 
	pushl	$3
	popl	%esi
	movb	$0, -172(%ebp, %esi, 1)
	#debug: assignment: idx = 0 ; 
	movl	$0, -12(%ebp)
	#debug: while: idx < cntbyte 
codegen_EmitCopyJunk_while_83:
	pushl	-12(%ebp)
	popl	%ebx
	cmpl	-8(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitCopyJunk_reltrue_84
	movl	$0, %eax
codegen_EmitCopyJunk_reltrue_84:
	testl	%eax, %eax
	jz	codegen_EmitCopyJunk_endwhile_83

	#debug: func-call: codegen_emit ( cg , "\tmovb\t(" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1240, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "), " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1218, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tmpreg ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovb\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+221, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tmpreg ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", (" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1222, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ")\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1226, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\taddl\t$1, " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1248, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , srcaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\taddl\t$1, " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1248, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , destaddr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 1 ; 
	pushl	-12(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	codegen_EmitCopyJunk_while_83
codegen_EmitCopyJunk_endwhile_83:

	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitCopyJunk_ret


codegen_EmitCopyJunk_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_EmitFastAssign
.type codegen_EmitFastAssign, @function
codegen_EmitFastAssign:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$216, %esp


	#debug: assignment: lhs = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: rhs = syntax_GetChild ( tree , 2 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -216(%ebp)
	#debug: assignment: cnt = syntax_CountChilds ( lhs ) ; 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -12(%ebp)
	#debug: assignment: cntresol = type_CountVarexprResolutions ( lhs ) ; 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CountVarexprResolutions
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( lhs , cnt - 1 ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-12(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: if: subtree -> tok . type == 4 
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_86
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_86:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_85
	jmp	codegen_EmitFastAssign_elsebl_85
codegen_EmitFastAssign_ifbl_85:
	#debug: assignment: idxspec = 1 ; 
	movl	$1, -20(%ebp)
	jmp	codegen_EmitFastAssign_endif_85

codegen_EmitFastAssign_elsebl_85:

	#debug: assignment: idxspec = 0 ; 
	movl	$0, -20(%ebp)
codegen_EmitFastAssign_endif_85:

	#debug: assignment: subtree = syntax_GetChild ( lhs , 0 ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: if: subtree -> tok . type != 43 
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	jne	codegen_EmitFastAssign_reltrue_88
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_88:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_87
	jmp	codegen_EmitFastAssign_elsebl_87
codegen_EmitFastAssign_ifbl_87:
	#debug: assignment: addrop = 1 ; 
	movl	$1, -24(%ebp)
	jmp	codegen_EmitFastAssign_endif_87

codegen_EmitFastAssign_elsebl_87:

	#debug: assignment: addrop = 0 ; 
	movl	$0, -24(%ebp)
codegen_EmitFastAssign_endif_87:

	#debug: assignment: subtree = syntax_GetChild ( lhs , addrop ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: assignment: varNode = symbol_FindVariable ( symtab , subtree -> tok ) ; 
	subl	$148, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindVariable
	addl	$148, %esp
	movl	%eax, -28(%ebp)
	#debug: if: varNode == 0 
	pushl	-28(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_90
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_90:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_89
	jmp	codegen_EmitFastAssign_elsebl_89
codegen_EmitFastAssign_ifbl_89:
	#debug: func-call: syntax_printTree ( subtree ) 
	subl	$4, %esp
	movl	-204(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_printTree
	addl	$4, %esp
	#debug: func-call: codegen_reportError ( cg , "Unknown variable.\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1259, 4(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitFastAssign_ret
	jmp	codegen_EmitFastAssign_endif_89

codegen_EmitFastAssign_elsebl_89:

codegen_EmitFastAssign_endif_89:

	#debug: assignment: vardef = varNode -> structure ; 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, -212(%ebp)
	#debug: assignment: varType = type_CreateType ( varNode -> structure ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	movl	%eax, -36(%ebp)
	#debug: if: addrop == 0 && idxspec == 0 && cntresol == 1 && ! type_IsAStructType ( varType ) && ! type_IsAArrayVar ( vardef ) 
	pushl	-24(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_93
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_93:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_92
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_94
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_94:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_92
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_95
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_95:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_92
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitFastAssign_logfactfalse_96
	movl	$0, %eax
codegen_EmitFastAssign_logfactfalse_96:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_92
	subl	$4, %esp
	movl	-212(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitFastAssign_logfactfalse_97
	movl	$0, %eax
codegen_EmitFastAssign_logfactfalse_97:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_92
	movl	$1, %eax
	jmp	codegen_EmitFastAssign_logtermtrue_92
codegen_EmitFastAssign_logtermfalse_92:
	movl	$0, %eax
codegen_EmitFastAssign_logtermtrue_92:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_91
	jmp	codegen_EmitFastAssign_elsebl_91
codegen_EmitFastAssign_ifbl_91:
	#debug: assignment: valType = codegen_EmitLogExpr ( cg , rhs , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , valType ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: func-call: codegen_CheckCasting ( cg , varType , valType , subtree -> tok ) 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-36(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$12, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_CheckCasting
	addl	$156, %esp
	#debug: if: type_IsLongSized ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_98
	jmp	codegen_EmitFastAssign_elsebl_98
codegen_EmitFastAssign_ifbl_98:
	#debug: assignment: valType = codegen_CastToInt ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 148(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFastAssign_endif_98

codegen_EmitFastAssign_elsebl_98:

	#debug: if: type_IsByteSized ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_99
	jmp	codegen_EmitFastAssign_elsebl_99
codegen_EmitFastAssign_ifbl_99:
	#debug: assignment: valType = codegen_CastToChar ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 148(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovb\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+221, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFastAssign_endif_99

codegen_EmitFastAssign_elsebl_99:

	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Internal compiler error: EmitFastAssign" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1278, 4(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitFastAssign_ret
codegen_EmitFastAssign_endif_99:

codegen_EmitFastAssign_endif_98:

	#debug: if: varNode -> type == 4 || varNode -> type == 6 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_102
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_102:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_logexprtrue_101
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$6, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_103
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_103:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_logexprtrue_101
	movl	$0, %eax
	jmp	codegen_EmitFastAssign_logexprfalse_101
codegen_EmitFastAssign_logexprtrue_101:
	movl	$1, %eax
codegen_EmitFastAssign_logexprfalse_101:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_100
	jmp	codegen_EmitFastAssign_elsebl_100
codegen_EmitFastAssign_ifbl_100:
	#debug: func-call: sprintf ( result , "%d(%%ebp)" , symbol_GetNonGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1318, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetNonGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	jmp	codegen_EmitFastAssign_endif_100

codegen_EmitFastAssign_elsebl_100:

	#debug: func-call: sprintf ( result , "symtab+%d" , symbol_GetGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1328, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
codegen_EmitFastAssign_endif_100:

	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitFastAssign_ret
	jmp	codegen_EmitFastAssign_endif_91

codegen_EmitFastAssign_elsebl_91:

codegen_EmitFastAssign_endif_91:

	#debug: if: addrop == 0 && idxspec == 1 && cntresol == 1 && type_IsAArrayVar ( vardef ) 
	pushl	-24(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_106
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_106:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_105
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_107
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_107:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_105
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_108
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_108:
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_105
	subl	$4, %esp
	movl	-212(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	jz	codegen_EmitFastAssign_logtermfalse_105
	movl	$1, %eax
	jmp	codegen_EmitFastAssign_logtermtrue_105
codegen_EmitFastAssign_logtermfalse_105:
	movl	$0, %eax
codegen_EmitFastAssign_logtermtrue_105:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_104
	jmp	codegen_EmitFastAssign_elsebl_104
codegen_EmitFastAssign_ifbl_104:
	#debug: assignment: elmType = type_CreateArrayElmType ( vardef ) ; 
	subl	$4, %esp
	movl	-212(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateArrayElmType
	addl	$4, %esp
	movl	%eax, -40(%ebp)
	#debug: if: type_IsAStructType ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_109
	jmp	codegen_EmitFastAssign_elsebl_109
codegen_EmitFastAssign_ifbl_109:
	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFastAssign_ret
	jmp	codegen_EmitFastAssign_endif_109

codegen_EmitFastAssign_elsebl_109:

codegen_EmitFastAssign_endif_109:

	#debug: assignment: subtree = syntax_GetChild ( lhs , cnt - 1 ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-12(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( lhs , cnt - 2 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-12(%ebp)
	popl	%ebx
	subl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -208(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 148(%esp)
	movl	-208(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -208(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-208(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: valType = codegen_EmitLogExpr ( cg , rhs , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , valType ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: func-call: codegen_CheckCasting ( cg , elmType , valType , subtree -> tok ) 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$12, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_CheckCasting
	addl	$156, %esp
	#debug: func-call: codegen_emit ( cg , "\tpopl\t%esi\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1346, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: type_IsLongSized ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_110
	jmp	codegen_EmitFastAssign_elsebl_110
codegen_EmitFastAssign_ifbl_110:
	#debug: assignment: valType = codegen_CastToInt ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 148(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFastAssign_endif_110

codegen_EmitFastAssign_elsebl_110:

	#debug: if: type_IsByteSized ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_111
	jmp	codegen_EmitFastAssign_elsebl_111
codegen_EmitFastAssign_ifbl_111:
	#debug: assignment: valType = codegen_CastToChar ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 148(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovb\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+221, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFastAssign_endif_111

codegen_EmitFastAssign_elsebl_111:

	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -204(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Internal compiler error: EmitFastAssign" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1278, 4(%esp)
	movl	%ebp, %eax
	addl	$-204, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return - 1 ; 
	pushl	$0
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	jmp	codegen_EmitFastAssign_ret
codegen_EmitFastAssign_endif_111:

codegen_EmitFastAssign_endif_110:

	#debug: if: varNode -> type == 4 || varNode -> type == 6 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_114
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_114:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_logexprtrue_113
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$6, %ebx
	movl	$1, %eax
	je	codegen_EmitFastAssign_reltrue_115
	movl	$0, %eax
codegen_EmitFastAssign_reltrue_115:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_logexprtrue_113
	movl	$0, %eax
	jmp	codegen_EmitFastAssign_logexprfalse_113
codegen_EmitFastAssign_logexprtrue_113:
	movl	$1, %eax
codegen_EmitFastAssign_logexprfalse_113:
	testl	%eax, %eax
	jnz	codegen_EmitFastAssign_ifbl_112
	jmp	codegen_EmitFastAssign_elsebl_112
codegen_EmitFastAssign_ifbl_112:
	#debug: func-call: sprintf ( result , "%d" , symbol_GetNonGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1358, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetNonGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( result , "(%%ebp, %%esi, %d)\n" , type_GetArrayElmSize ( symtab , vardef ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1361, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-212(%ebp), %eax
	movl	%eax, 4(%esp)
	call	type_GetArrayElmSize
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFastAssign_endif_112

codegen_EmitFastAssign_elsebl_112:

	#debug: func-call: sprintf ( result , "symtab+%d" , symbol_GetGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1328, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( result , "(, %%esi, %d)\n" , type_GetArrayElmSize ( symtab , vardef ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1381, 4(%esp)
	subl	$8, %esp
	movl	-216(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-212(%ebp), %eax
	movl	%eax, 4(%esp)
	call	type_GetArrayElmSize
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-200, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
codegen_EmitFastAssign_endif_112:

	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( elmType ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitFastAssign_ret
	jmp	codegen_EmitFastAssign_endif_104

codegen_EmitFastAssign_elsebl_104:

codegen_EmitFastAssign_endif_104:

	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFastAssign_ret


codegen_EmitFastAssign_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree ) 
.globl codegen_EmitAssign
.type codegen_EmitAssign, @function
codegen_EmitAssign:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$336, %esp


	#debug: func-call: codegen_debug ( cg , "assignment: " , tree ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1396, 4(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_debug
	addl	$12, %esp
	#debug: func-call: strcpy ( result , "" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: if: cg -> enOptFastassign 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$16, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_116
	jmp	codegen_EmitAssign_elsebl_116
codegen_EmitAssign_ifbl_116:
	#debug: assignment: ret = codegen_EmitFastAssign ( cg , tree ) ; 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitFastAssign
	addl	$8, %esp
	movl	%eax, -336(%ebp)
	#debug: if: ret != 0 
	pushl	-336(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitAssign_reltrue_118
	movl	$0, %eax
codegen_EmitAssign_reltrue_118:
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_117
	jmp	codegen_EmitAssign_elsebl_117
codegen_EmitAssign_ifbl_117:
	#debug: return: return ret ; 
	movl	-336(%ebp), %eax
	jmp	codegen_EmitAssign_ret
	jmp	codegen_EmitAssign_endif_117

codegen_EmitAssign_elsebl_117:

codegen_EmitAssign_endif_117:

	jmp	codegen_EmitAssign_endif_116

codegen_EmitAssign_elsebl_116:

codegen_EmitAssign_endif_116:

	#debug: assignment: varType = codegen_EmitVarExprAdress ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitVarExprAdress
	addl	$12, %esp
	movl	%eax, -324(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: valType = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 2 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -328(%ebp)
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , valType ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	movl	-328(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: if: strcmp ( result , "ebx" ) == 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1409, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitAssign_reltrue_120
	movl	$0, %eax
codegen_EmitAssign_reltrue_120:
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_119
	jmp	codegen_EmitAssign_elsebl_119
codegen_EmitAssign_ifbl_119:
	#debug: func-call: strcpy ( addr , "%eax" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitAssign_endif_119

codegen_EmitAssign_elsebl_119:

	#debug: func-call: strcpy ( addr , "%ebx" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitAssign_endif_119:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1413, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , addr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -332(%ebp)
	#debug: func-call: codegen_CheckCasting ( cg , varType , valType , subtree -> tok ) 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-328(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-332, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$12, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_CheckCasting
	addl	$156, %esp
	#debug: if: type_IsLongSized ( varType ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_121
	jmp	codegen_EmitAssign_elsebl_121
codegen_EmitAssign_ifbl_121:
	#debug: assignment: valType = codegen_CastToInt ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-332, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-328(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -328(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", (" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1222, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , addr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ")\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1226, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitAssign_endif_121

codegen_EmitAssign_elsebl_121:

	#debug: if: type_IsByteSized ( varType ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_122
	jmp	codegen_EmitAssign_elsebl_122
codegen_EmitAssign_ifbl_122:
	#debug: assignment: valType = codegen_CastToChar ( cg , subtree -> tok , result , valType ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-332, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 148(%esp)
	movl	-328(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -328(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tmovb\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+221, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", (" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1222, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , addr ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ")\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1226, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitAssign_endif_122

codegen_EmitAssign_elsebl_122:

	#debug: if: type_IsAStructType ( varType ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitAssign_ifbl_123
	jmp	codegen_EmitAssign_elsebl_123
codegen_EmitAssign_ifbl_123:
	#debug: func-call: codegen_EmitCopyJunk ( cg , addr , result , symbol_Sizeof_DataType ( cg -> parse -> symTable , varType ) ) 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-320, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-160, %eax
	movl	%eax, 8(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-324(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_DataType
	addl	$8, %esp
	movl	%eax, 12(%esp)
	call	codegen_EmitCopyJunk
	addl	$16, %esp
	jmp	codegen_EmitAssign_endif_123

codegen_EmitAssign_elsebl_123:

	#debug: func-call: codegen_reportError ( cg , "Internal Error: Unhandled case in assignment." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1420, 4(%esp)
	movl	%ebp, %eax
	addl	$-332, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_EmitAssign_endif_123:

codegen_EmitAssign_endif_122:

codegen_EmitAssign_endif_121:

	#debug: func-call: syntax_FreeSyntaxTree ( varType ) 
	subl	$4, %esp
	movl	-324(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( valType ) 
	subl	$4, %esp
	movl	-328(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	codegen_EmitAssign_ret


codegen_EmitAssign_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( ) 
.globl codegen_CreateIntType
.type codegen_CreateIntType, @function
codegen_CreateIntType:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$148, %esp


	#debug: func-call: strcpy ( tok . content , "int" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1466, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: assignment: tok . type = 36 ; 
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$0, %eax
	pushl	%eax
	popl	%ebx
	movl	$36, (%ebx)
	#debug: assignment: tree = syntax_CreateTreeNode ( ) ; 
	subl	$0, %esp
	call	syntax_CreateTreeNode
	addl	$0, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: syntax_AddChildNode ( tree , tok ) 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-148, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	syntax_AddChildNode
	addl	$148, %esp
	#debug: return: return tree ; 
	movl	-4(%ebp), %eax
	jmp	codegen_CreateIntType_ret


codegen_CreateIntType_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( ) 
.globl codegen_CreateCharType
.type codegen_CreateCharType, @function
codegen_CreateCharType:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$148, %esp


	#debug: func-call: strcpy ( tok . content , "char" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1470, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: assignment: tok . type = 37 ; 
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$0, %eax
	pushl	%eax
	popl	%ebx
	movl	$37, (%ebx)
	#debug: assignment: tree = syntax_CreateTreeNode ( ) ; 
	subl	$0, %esp
	call	syntax_CreateTreeNode
	addl	$0, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: syntax_AddChildNode ( tree , tok ) 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-148, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	syntax_AddChildNode
	addl	$148, %esp
	#debug: return: return tree ; 
	movl	-4(%ebp), %eax
	jmp	codegen_CreateCharType_ret


codegen_CreateCharType_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( ) 
.globl codegen_CreateVoidPntType
.type codegen_CreateVoidPntType, @function
codegen_CreateVoidPntType:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$148, %esp


	#debug: assignment: tree = syntax_CreateTreeNode ( ) ; 
	subl	$0, %esp
	call	syntax_CreateTreeNode
	addl	$0, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: tok . type = 38 ; 
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$0, %eax
	pushl	%eax
	popl	%ebx
	movl	$38, (%ebx)
	#debug: func-call: strcpy ( tok . content , "void" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1475, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: func-call: syntax_AddChildNode ( tree , tok ) 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-148, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	syntax_AddChildNode
	addl	$148, %esp
	#debug: assignment: tok . type = 18 ; 
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$0, %eax
	pushl	%eax
	popl	%ebx
	movl	$18, (%ebx)
	#debug: func-call: strcpy ( tok . content , "*" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-148, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1480, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: func-call: syntax_AddChildNode ( tree , tok ) 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-148, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	syntax_AddChildNode
	addl	$148, %esp
	#debug: return: return tree ; 
	movl	-4(%ebp), %eax
	jmp	codegen_CreateVoidPntType_ret


codegen_CreateVoidPntType_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , token tok , char * result , syntaxTreeNode * tree ) 
.globl codegen_CastToInt
.type codegen_CastToInt, @function
codegen_CastToInt:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: if: tree == 0 
	pushl	160(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_CastToInt_reltrue_125
	movl	$0, %eax
codegen_CastToInt_reltrue_125:
	testl	%eax, %eax
	jnz	codegen_CastToInt_ifbl_124
	jmp	codegen_CastToInt_elsebl_124
codegen_CastToInt_ifbl_124:
	#debug: return: return codegen_CreateIntType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateIntType
	addl	$0, %esp
	jmp	codegen_CastToInt_ret
	jmp	codegen_CastToInt_endif_124

codegen_CastToInt_elsebl_124:

codegen_CastToInt_endif_124:

	#debug: if: type_IsAIntType ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAIntType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CastToInt_ifbl_126
	jmp	codegen_CastToInt_elsebl_126
codegen_CastToInt_ifbl_126:
	#debug: return: return tree ; 
	movl	160(%ebp), %eax
	jmp	codegen_CastToInt_ret
	jmp	codegen_CastToInt_endif_126

codegen_CastToInt_elsebl_126:

codegen_CastToInt_endif_126:

	#debug: if: type_IsACharType ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsACharType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CastToInt_ifbl_127
	jmp	codegen_CastToInt_elsebl_127
codegen_CastToInt_ifbl_127:
	#debug: func-call: codegen_emit ( cg , "\tmovsbl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1482, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	156(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	156(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_CastToInt_endif_127

codegen_CastToInt_elsebl_127:

	#debug: if: type_IsAPointerType ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CastToInt_ifbl_128
	jmp	codegen_CastToInt_elsebl_128
codegen_CastToInt_ifbl_128:
	jmp	codegen_CastToInt_endif_128

codegen_CastToInt_elsebl_128:

	#debug: func-call: codegen_reportError ( cg , "Can not cast to int." , tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1491, 4(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_CastToInt_endif_128:

codegen_CastToInt_endif_127:

	#debug: func-call: syntax_FreeSyntaxTree ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return codegen_CreateIntType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateIntType
	addl	$0, %esp
	jmp	codegen_CastToInt_ret


codegen_CastToInt_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , token tok , char * result , syntaxTreeNode * tree ) 
.globl codegen_CastToChar
.type codegen_CastToChar, @function
codegen_CastToChar:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$1, %esp


	#debug: if: tree == 0 
	pushl	160(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_CastToChar_reltrue_130
	movl	$0, %eax
codegen_CastToChar_reltrue_130:
	testl	%eax, %eax
	jnz	codegen_CastToChar_ifbl_129
	jmp	codegen_CastToChar_elsebl_129
codegen_CastToChar_ifbl_129:
	#debug: return: return codegen_CreateCharType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateCharType
	addl	$0, %esp
	jmp	codegen_CastToChar_ret
	jmp	codegen_CastToChar_endif_129

codegen_CastToChar_elsebl_129:

codegen_CastToChar_endif_129:

	#debug: if: type_IsACharType ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsACharType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CastToChar_ifbl_131
	jmp	codegen_CastToChar_elsebl_131
codegen_CastToChar_ifbl_131:
	#debug: return: return tree ; 
	movl	160(%ebp), %eax
	jmp	codegen_CastToChar_ret
	jmp	codegen_CastToChar_endif_131

codegen_CastToChar_elsebl_131:

codegen_CastToChar_endif_131:

	#debug: if: type_IsAIntType ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAIntType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_CastToChar_ifbl_132
	jmp	codegen_CastToChar_elsebl_132
codegen_CastToChar_ifbl_132:
	#debug: if: result [ 0 ] == '%' 
	pushl	$0
	movl	%ebp, %eax
	addl	$156, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$37, %ebx
	movl	$1, %eax
	je	codegen_CastToChar_reltrue_134
	movl	$0, %eax
codegen_CastToChar_reltrue_134:
	testl	%eax, %eax
	jnz	codegen_CastToChar_ifbl_133
	jmp	codegen_CastToChar_elsebl_133
codegen_CastToChar_ifbl_133:
	#debug: assignment: regname = result [ 2 ] ; 
	pushl	$2
	movl	%ebp, %eax
	addl	$156, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	movb	(%eax), %al
	movb	%al, -1(%ebp)
	#debug: func-call: strcpy ( result , "%Xl" ) 
	subl	$8, %esp
	movl	156(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1512, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: assignment: result [ 1 ] = regname ; 
	pushl	$1
	movl	%ebp, %eax
	addl	$156, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	pushl	%eax
	movb	-1(%ebp), %ah
	popl	%ebx
	movb	%ah, (%ebx)
	jmp	codegen_CastToChar_endif_133

codegen_CastToChar_elsebl_133:

codegen_CastToChar_endif_133:

	jmp	codegen_CastToChar_endif_132

codegen_CastToChar_elsebl_132:

	#debug: func-call: codegen_reportError ( cg , "Can not cast to char." , tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1516, 4(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_CastToChar_endif_132:

	#debug: func-call: syntax_FreeSyntaxTree ( tree ) 
	subl	$4, %esp
	movl	160(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return codegen_CreateCharType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateCharType
	addl	$0, %esp
	jmp	codegen_CastToChar_ret


codegen_CastToChar_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitAtomicValue
.type codegen_EmitAtomicValue, @function
codegen_EmitAtomicValue:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp


	#debug: assignment: tree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 12(%ebp)
	#debug: if: tree -> tok . type == 44 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$44, %ebx
	movl	$1, %eax
	je	codegen_EmitAtomicValue_reltrue_136
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_136:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_135
	jmp	codegen_EmitAtomicValue_elsebl_135
codegen_EmitAtomicValue_ifbl_135:
	#debug: func-call: strcpy ( result + 1 , tree -> tok . content ) 
	subl	$8, %esp
	pushl	16(%ebp)
	popl	%ebx
	movl	$1, %esi
	imull	$1, %esi
	addl	%esi, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: assignment: result [ 0 ] = '$' ; 
	pushl	$0
	movl	%ebp, %eax
	addl	$16, %eax
	movl	(%eax), %eax
	popl	%esi
	addl	%esi, %eax
	pushl	%eax
	popl	%ebx
	movb	$36, (%ebx)
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitAtomicValue_ret
	jmp	codegen_EmitAtomicValue_endif_135

codegen_EmitAtomicValue_elsebl_135:

codegen_EmitAtomicValue_endif_135:

	#debug: if: tree -> tok . type == 46 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$46, %ebx
	movl	$1, %eax
	je	codegen_EmitAtomicValue_reltrue_138
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_138:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_137
	jmp	codegen_EmitAtomicValue_elsebl_137
codegen_EmitAtomicValue_ifbl_137:
	#debug: func-call: sprintf ( result , "$%d" , type_ConvertSinglechar ( tree -> tok . content ) ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1538, 4(%esp)
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$16, %eax
	movl	%eax, 0(%esp)
	call	type_ConvertSinglechar
	addl	$4, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitAtomicValue_ret
	jmp	codegen_EmitAtomicValue_endif_137

codegen_EmitAtomicValue_elsebl_137:

codegen_EmitAtomicValue_endif_137:

	#debug: if: tree -> tok . type == 45 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$45, %ebx
	movl	$1, %eax
	je	codegen_EmitAtomicValue_reltrue_140
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_140:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_139
	jmp	codegen_EmitAtomicValue_elsebl_139
codegen_EmitAtomicValue_ifbl_139:
	#debug: assignment: node = symbol_FindString ( cg -> parse -> symTable , tree -> tok ) ; 
	subl	$148, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindString
	addl	$148, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: sprintf ( result , "$symtab+%d" , symbol_GetGlobalOffset ( cg -> parse -> symTable , node ) ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1542, 4(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitAtomicValue_ret
	jmp	codegen_EmitAtomicValue_endif_139

codegen_EmitAtomicValue_elsebl_139:

codegen_EmitAtomicValue_endif_139:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -8(%ebp)
	#debug: if: subtree -> tok . type == 39 
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$39, %ebx
	movl	$1, %eax
	je	codegen_EmitAtomicValue_reltrue_142
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_142:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_141
	jmp	codegen_EmitAtomicValue_elsebl_141
codegen_EmitAtomicValue_ifbl_141:
	#debug: func-call: sprintf ( result , "$%d" , symbol_Sizeof_DataType ( cg -> parse -> symTable , syntax_GetChild ( tree , 2 ) ) ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1538, 4(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_DataType
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitAtomicValue_ret
	jmp	codegen_EmitAtomicValue_endif_141

codegen_EmitAtomicValue_elsebl_141:

codegen_EmitAtomicValue_endif_141:

	#debug: if: syntax_CountChilds ( tree ) > 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jg	codegen_EmitAtomicValue_reltrue_144
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_144:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_143
	jmp	codegen_EmitAtomicValue_elsebl_143
codegen_EmitAtomicValue_ifbl_143:
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -8(%ebp)
	#debug: if: subtree -> tok . type == 5 
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$5, %ebx
	movl	$1, %eax
	je	codegen_EmitAtomicValue_reltrue_146
	movl	$0, %eax
codegen_EmitAtomicValue_reltrue_146:
	testl	%eax, %eax
	jnz	codegen_EmitAtomicValue_ifbl_145
	jmp	codegen_EmitAtomicValue_elsebl_145
codegen_EmitAtomicValue_ifbl_145:
	#debug: return: return codegen_EmitFuncCall ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitFuncCall
	addl	$12, %esp
	jmp	codegen_EmitAtomicValue_ret
	jmp	codegen_EmitAtomicValue_endif_145

codegen_EmitAtomicValue_elsebl_145:

codegen_EmitAtomicValue_endif_145:

	jmp	codegen_EmitAtomicValue_endif_143

codegen_EmitAtomicValue_elsebl_143:

codegen_EmitAtomicValue_endif_143:

	#debug: return: return codegen_EmitVariableExpr ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitVariableExpr
	addl	$12, %esp
	jmp	codegen_EmitAtomicValue_ret


codegen_EmitAtomicValue_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitArithFactor
.type codegen_EmitArithFactor, @function
codegen_EmitArithFactor:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitArithFactor_reltrue_148
	movl	$0, %eax
codegen_EmitArithFactor_reltrue_148:
	testl	%eax, %eax
	jnz	codegen_EmitArithFactor_ifbl_147
	jmp	codegen_EmitArithFactor_elsebl_147
codegen_EmitArithFactor_ifbl_147:
	#debug: return: return codegen_EmitAtomicValue ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAtomicValue
	addl	$12, %esp
	jmp	codegen_EmitArithFactor_ret
	jmp	codegen_EmitArithFactor_endif_147

codegen_EmitArithFactor_elsebl_147:

codegen_EmitArithFactor_endif_147:

	#debug: if: syntax_CountChilds ( tree ) == 2 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$2, %ebx
	movl	$1, %eax
	je	codegen_EmitArithFactor_reltrue_150
	movl	$0, %eax
codegen_EmitArithFactor_reltrue_150:
	testl	%eax, %eax
	jnz	codegen_EmitArithFactor_ifbl_149
	jmp	codegen_EmitArithFactor_elsebl_149
codegen_EmitArithFactor_ifbl_149:
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: type = codegen_EmitAtomicValue ( cg , syntax_GetChild ( tree , 1 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAtomicValue
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	#debug: if: strcmp ( result , "%eax" ) != 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitArithFactor_reltrue_152
	movl	$0, %eax
codegen_EmitArithFactor_reltrue_152:
	testl	%eax, %eax
	jnz	codegen_EmitArithFactor_ifbl_151
	jmp	codegen_EmitArithFactor_elsebl_151
codegen_EmitArithFactor_ifbl_151:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithFactor_endif_151

codegen_EmitArithFactor_elsebl_151:

codegen_EmitArithFactor_endif_151:

	#debug: func-call: codegen_emit ( cg , "\tnotl\t%eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1553, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-8(%ebp), %eax
	jmp	codegen_EmitArithFactor_ret
	jmp	codegen_EmitArithFactor_endif_149

codegen_EmitArithFactor_elsebl_149:

codegen_EmitArithFactor_endif_149:

	#debug: return: return codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 1 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	jmp	codegen_EmitArithFactor_ret


codegen_EmitArithFactor_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitArithTerm
.type codegen_EmitArithTerm, @function
codegen_EmitArithTerm:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$176, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_154
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_154:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_153
	jmp	codegen_EmitArithTerm_elsebl_153
codegen_EmitArithTerm_ifbl_153:
	#debug: return: return codegen_EmitArithFactor ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithFactor
	addl	$12, %esp
	jmp	codegen_EmitArithTerm_ret
	jmp	codegen_EmitArithTerm_endif_153

codegen_EmitArithTerm_elsebl_153:

codegen_EmitArithTerm_endif_153:

	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -12(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: type = codegen_EmitArithFactor ( cg , subtree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithFactor
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = 2 ; 
	movl	$2, -16(%ebp)
	#debug: while: idx < cnt 
codegen_EmitArithTerm_while_155:
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	-12(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitArithTerm_reltrue_156
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_156:
	testl	%eax, %eax
	jz	codegen_EmitArithTerm_endwhile_155

	#debug: assignment: subtree = syntax_GetChild ( tree , idx - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-16(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-8(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = codegen_EmitArithFactor ( cg , syntax_GetChild ( tree , idx ) , result2 ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithFactor
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result2 , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	#debug: if: subtree -> tok . type == 19 || subtree -> tok . type == 20 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$19, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_159
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_159:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_logexprtrue_158
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$20, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_160
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_160:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_logexprtrue_158
	movl	$0, %eax
	jmp	codegen_EmitArithTerm_logexprfalse_158
codegen_EmitArithTerm_logexprtrue_158:
	movl	$1, %eax
codegen_EmitArithTerm_logexprfalse_158:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_157
	jmp	codegen_EmitArithTerm_elsebl_157
codegen_EmitArithTerm_ifbl_157:
	#debug: func-call: codegen_EmitAvoidConstant ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: if: strcmp ( result2 , "%eax" ) == 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_162
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_162:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_161
	jmp	codegen_EmitArithTerm_elsebl_161
codegen_EmitArithTerm_ifbl_161:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %ebx\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1192, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result2 , "%ebx" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_161

codegen_EmitArithTerm_elsebl_161:

codegen_EmitArithTerm_endif_161:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t%eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1565, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$0, %edx\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1577, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tidivl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1593, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: subtree -> tok . type == 19 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$19, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_164
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_164:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_163
	jmp	codegen_EmitArithTerm_elsebl_163
codegen_EmitArithTerm_ifbl_163:
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_163

codegen_EmitArithTerm_elsebl_163:

	#debug: func-call: strcpy ( result , "%edx" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1601, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitArithTerm_endif_163:

	jmp	codegen_EmitArithTerm_endif_157

codegen_EmitArithTerm_elsebl_157:

	#debug: if: strcmp ( result2 , "%ebx" ) == 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_166
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_166:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_165
	jmp	codegen_EmitArithTerm_elsebl_165
codegen_EmitArithTerm_ifbl_165:
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_165

codegen_EmitArithTerm_elsebl_165:

	#debug: func-call: strcpy ( result , "%ebx" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitArithTerm_endif_165:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1413, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: subtree -> tok . type == 21 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$21, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_168
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_168:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_167
	jmp	codegen_EmitArithTerm_elsebl_167
codegen_EmitArithTerm_ifbl_167:
	#debug: func-call: codegen_emit ( cg , "\tandl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1606, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_167

codegen_EmitArithTerm_elsebl_167:

codegen_EmitArithTerm_endif_167:

	#debug: if: subtree -> tok . type == 23 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$23, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_170
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_170:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_169
	jmp	codegen_EmitArithTerm_elsebl_169
codegen_EmitArithTerm_ifbl_169:
	#debug: func-call: codegen_emit ( cg , "\txorl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1613, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_169

codegen_EmitArithTerm_elsebl_169:

codegen_EmitArithTerm_endif_169:

	#debug: if: subtree -> tok . type == 18 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$18, %ebx
	movl	$1, %eax
	je	codegen_EmitArithTerm_reltrue_172
	movl	$0, %eax
codegen_EmitArithTerm_reltrue_172:
	testl	%eax, %eax
	jnz	codegen_EmitArithTerm_ifbl_171
	jmp	codegen_EmitArithTerm_elsebl_171
codegen_EmitArithTerm_ifbl_171:
	#debug: func-call: codegen_emit ( cg , "\timull\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1620, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithTerm_endif_171

codegen_EmitArithTerm_elsebl_171:

codegen_EmitArithTerm_endif_171:

	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
codegen_EmitArithTerm_endif_157:

	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 2 ; 
	pushl	-16(%ebp)
	popl	%ebx
	addl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	codegen_EmitArithTerm_while_155
codegen_EmitArithTerm_endwhile_155:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t%eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1565, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-8(%ebp), %eax
	jmp	codegen_EmitArithTerm_ret


codegen_EmitArithTerm_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitArithExpr
.type codegen_EmitArithExpr, @function
codegen_EmitArithExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$340, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_174
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_174:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_173
	jmp	codegen_EmitArithExpr_elsebl_173
codegen_EmitArithExpr_ifbl_173:
	#debug: return: return codegen_EmitArithTerm ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithTerm
	addl	$12, %esp
	jmp	codegen_EmitArithExpr_ret
	jmp	codegen_EmitArithExpr_endif_173

codegen_EmitArithExpr_elsebl_173:

codegen_EmitArithExpr_endif_173:

	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: if: subtree -> tok . type == 17 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$17, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_176
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_176:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_175
	jmp	codegen_EmitArithExpr_elsebl_175
codegen_EmitArithExpr_ifbl_175:
	#debug: func-call: codegen_emit ( cg , "\tpushl\t$0\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1628, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: type = codegen_CreateIntType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateIntType
	addl	$0, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: idx = 1 ; 
	movl	$1, -20(%ebp)
	jmp	codegen_EmitArithExpr_endif_175

codegen_EmitArithExpr_elsebl_175:

	#debug: assignment: type = codegen_EmitArithTerm ( cg , subtree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithTerm
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: if: ! type_IsAPointerType ( type ) 
	subl	$4, %esp
	movl	-8(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitArithExpr_logfactfalse_178
	movl	$0, %eax
codegen_EmitArithExpr_logfactfalse_178:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_177
	jmp	codegen_EmitArithExpr_elsebl_177
codegen_EmitArithExpr_ifbl_177:
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	jmp	codegen_EmitArithExpr_endif_177

codegen_EmitArithExpr_elsebl_177:

codegen_EmitArithExpr_endif_177:

	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = 2 ; 
	movl	$2, -20(%ebp)
codegen_EmitArithExpr_endif_175:

	#debug: while: idx < cnt 
codegen_EmitArithExpr_while_179:
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	-16(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitArithExpr_reltrue_180
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_180:
	testl	%eax, %eax
	jz	codegen_EmitArithExpr_endwhile_179

	#debug: assignment: subtree = syntax_GetChild ( tree , idx - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-20(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: oldtype = type ; 
	movl	-8(%ebp), %eax
	movl	%eax, -12(%ebp)
	#debug: assignment: type = codegen_EmitArithTerm ( cg , syntax_GetChild ( tree , idx ) , result2 ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithTerm
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result2 , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	#debug: if: strcmp ( result2 , "%ebx" ) == 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_182
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_182:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_181
	jmp	codegen_EmitArithExpr_elsebl_181
codegen_EmitArithExpr_ifbl_181:
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitArithExpr_endif_181

codegen_EmitArithExpr_elsebl_181:

	#debug: func-call: strcpy ( result , "%ebx" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitArithExpr_endif_181:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1413, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: subtree = syntax_GetChild ( tree , idx - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-20(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: if: type_IsAPointerType ( oldtype ) && ( subtree -> tok . type == 16 || subtree -> tok . type == 17 ) 
	subl	$4, %esp
	movl	-12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	jz	codegen_EmitArithExpr_logtermfalse_184
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$16, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_186
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_186:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_logexprtrue_185
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$17, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_187
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_187:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_logexprtrue_185
	movl	$0, %eax
	jmp	codegen_EmitArithExpr_logexprfalse_185
codegen_EmitArithExpr_logexprtrue_185:
	movl	$1, %eax
codegen_EmitArithExpr_logexprfalse_185:
	testl	%eax, %eax
	jz	codegen_EmitArithExpr_logtermfalse_184
	movl	$1, %eax
	jmp	codegen_EmitArithExpr_logtermtrue_184
codegen_EmitArithExpr_logtermfalse_184:
	movl	$0, %eax
codegen_EmitArithExpr_logtermtrue_184:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_183
	jmp	codegen_EmitArithExpr_elsebl_183
codegen_EmitArithExpr_ifbl_183:
	#debug: assignment: subtree = type_RemoveStarFromType ( oldtype ) ; 
	subl	$4, %esp
	movl	-12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_RemoveStarFromType
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: func-call: sprintf ( result3 , "\tmovl\t$%d, %%esi\n" , symbol_Sizeof_DataType ( cg -> parse -> symTable , subtree ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-340, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1639, 4(%esp)
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_DataType
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result3 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-340, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\timull\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1620, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %esi\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1657, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result2 , "%esi" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1665, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( subtree ) 
	subl	$4, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: subtree = oldtype ; 
	movl	-12(%ebp), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: oldtype = type ; 
	movl	-8(%ebp), %eax
	movl	%eax, -12(%ebp)
	#debug: assignment: type = subtree ; 
	movl	-4(%ebp), %eax
	movl	%eax, -8(%ebp)
	jmp	codegen_EmitArithExpr_endif_183

codegen_EmitArithExpr_elsebl_183:

codegen_EmitArithExpr_endif_183:

	#debug: assignment: subtree = syntax_GetChild ( tree , idx - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-20(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -4(%ebp)
	#debug: if: subtree -> tok . type == 16 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$16, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_189
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_189:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_188
	jmp	codegen_EmitArithExpr_elsebl_188
codegen_EmitArithExpr_ifbl_188:
	#debug: func-call: codegen_emit ( cg , "\taddl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1670, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithExpr_endif_188

codegen_EmitArithExpr_elsebl_188:

codegen_EmitArithExpr_endif_188:

	#debug: if: subtree -> tok . type == 17 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$17, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_191
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_191:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_190
	jmp	codegen_EmitArithExpr_elsebl_190
codegen_EmitArithExpr_ifbl_190:
	#debug: func-call: codegen_emit ( cg , "\tsubl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1677, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithExpr_endif_190

codegen_EmitArithExpr_elsebl_190:

codegen_EmitArithExpr_endif_190:

	#debug: if: subtree -> tok . type == 22 
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$22, %ebx
	movl	$1, %eax
	je	codegen_EmitArithExpr_reltrue_193
	movl	$0, %eax
codegen_EmitArithExpr_reltrue_193:
	testl	%eax, %eax
	jnz	codegen_EmitArithExpr_ifbl_192
	jmp	codegen_EmitArithExpr_elsebl_192
codegen_EmitArithExpr_ifbl_192:
	#debug: func-call: codegen_emit ( cg , "\torl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1684, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitArithExpr_endif_192

codegen_EmitArithExpr_elsebl_192:

codegen_EmitArithExpr_endif_192:

	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-180, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 2 ; 
	pushl	-20(%ebp)
	popl	%ebx
	addl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -20(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( oldtype ) 
	subl	$4, %esp
	movl	-12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	jmp	codegen_EmitArithExpr_while_179
codegen_EmitArithExpr_endwhile_179:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t%eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1565, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-8(%ebp), %eax
	jmp	codegen_EmitArithExpr_ret


codegen_EmitArithExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitRelExpr
.type codegen_EmitRelExpr, @function
codegen_EmitRelExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$336, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_195
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_195:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_194
	jmp	codegen_EmitRelExpr_elsebl_194
codegen_EmitRelExpr_ifbl_194:
	#debug: return: return codegen_EmitArithExpr ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithExpr
	addl	$12, %esp
	jmp	codegen_EmitRelExpr_ret
	jmp	codegen_EmitRelExpr_endif_194

codegen_EmitRelExpr_elsebl_194:

codegen_EmitRelExpr_endif_194:

	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -336(%ebp)
	#debug: assignment: blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: type = codegen_EmitArithExpr ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithExpr
	addl	$12, %esp
	movl	%eax, -332(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-336, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-332(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -332(%ebp)
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-332(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = codegen_EmitArithExpr ( cg , syntax_GetChild ( tree , 2 ) , result2 ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$2, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-164, %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitArithExpr
	addl	$12, %esp
	movl	%eax, -332(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result2 , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-336, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	%ebp, %eax
	addl	$-164, %eax
	movl	%eax, 148(%esp)
	movl	-332(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -332(%ebp)
	#debug: if: strcmp ( result2 , "%ebx" ) == 0 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-164, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_197
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_197:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_196
	jmp	codegen_EmitRelExpr_elsebl_196
codegen_EmitRelExpr_ifbl_196:
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_196

codegen_EmitRelExpr_elsebl_196:

	#debug: func-call: strcpy ( result , "%ebx" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitRelExpr_endif_196:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1413, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tcmpl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1690, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-164, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$1, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1697, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: reltok = & subtree -> tok ; 
	movl	%ebp, %eax
	addl	$-336, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%eax, -328(%ebp)
	#debug: if: reltok -> type == 26 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$26, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_199
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_199:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_198
	jmp	codegen_EmitRelExpr_elsebl_198
codegen_EmitRelExpr_ifbl_198:
	#debug: func-call: codegen_emit ( cg , "\tje\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1713, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_198

codegen_EmitRelExpr_elsebl_198:

	#debug: if: reltok -> type == 27 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$27, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_201
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_201:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_200
	jmp	codegen_EmitRelExpr_elsebl_200
codegen_EmitRelExpr_ifbl_200:
	#debug: func-call: codegen_emit ( cg , "\tjne\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1718, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_200

codegen_EmitRelExpr_elsebl_200:

	#debug: if: reltok -> type == 28 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$28, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_203
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_203:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_202
	jmp	codegen_EmitRelExpr_elsebl_202
codegen_EmitRelExpr_ifbl_202:
	#debug: func-call: codegen_emit ( cg , "\tjl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1724, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_202

codegen_EmitRelExpr_elsebl_202:

	#debug: if: reltok -> type == 29 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$29, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_205
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_205:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_204
	jmp	codegen_EmitRelExpr_elsebl_204
codegen_EmitRelExpr_ifbl_204:
	#debug: func-call: codegen_emit ( cg , "\tjle\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1729, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_204

codegen_EmitRelExpr_elsebl_204:

	#debug: if: reltok -> type == 30 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$30, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_207
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_207:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_206
	jmp	codegen_EmitRelExpr_elsebl_206
codegen_EmitRelExpr_ifbl_206:
	#debug: func-call: codegen_emit ( cg , "\tjg\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1735, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_206

codegen_EmitRelExpr_elsebl_206:

	#debug: if: reltok -> type == 31 
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$31, %ebx
	movl	$1, %eax
	je	codegen_EmitRelExpr_reltrue_209
	movl	$0, %eax
codegen_EmitRelExpr_reltrue_209:
	testl	%eax, %eax
	jnz	codegen_EmitRelExpr_ifbl_208
	jmp	codegen_EmitRelExpr_elsebl_208
codegen_EmitRelExpr_ifbl_208:
	#debug: func-call: codegen_emit ( cg , "\tjge\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1740, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitRelExpr_endif_208

codegen_EmitRelExpr_elsebl_208:

	#debug: func-call: codegen_reportError ( cg , "Unknown relational operator." , * reltok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1746, 4(%esp)
	movl	%ebp, %eax
	addl	$-328, %eax
	movl	(%eax), %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_EmitRelExpr_endif_208:

codegen_EmitRelExpr_endif_206:

codegen_EmitRelExpr_endif_204:

codegen_EmitRelExpr_endif_202:

codegen_EmitRelExpr_endif_200:

codegen_EmitRelExpr_endif_198:

	#debug: func-call: sprintf ( tmp , "%s_reltrue_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1775, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	%eax, 4(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$0, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1791, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_reltrue_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1807, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-324, %eax
	movl	%eax, 4(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-332(%ebp), %eax
	jmp	codegen_EmitRelExpr_ret


codegen_EmitRelExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitLogFactor
.type codegen_EmitLogFactor, @function
codegen_EmitLogFactor:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$172, %esp


	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -12(%ebp)
	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitLogFactor_reltrue_211
	movl	$0, %eax
codegen_EmitLogFactor_reltrue_211:
	testl	%eax, %eax
	jnz	codegen_EmitLogFactor_ifbl_210
	jmp	codegen_EmitLogFactor_elsebl_210
codegen_EmitLogFactor_ifbl_210:
	#debug: return: return codegen_EmitRelExpr ( cg , subtree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitRelExpr
	addl	$12, %esp
	jmp	codegen_EmitLogFactor_ret
	jmp	codegen_EmitLogFactor_endif_210

codegen_EmitLogFactor_elsebl_210:

codegen_EmitLogFactor_endif_210:

	#debug: assignment: blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: type = codegen_EmitRelExpr ( cg , syntax_GetChild ( tree , 1 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitRelExpr
	addl	$12, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -8(%ebp)
	#debug: func-call: codegen_EmitAvoidConstant ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , "\ttestl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+608, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$1, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1697, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjz\t%s_logfactfalse_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1824, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$0, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1791, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_logfactfalse_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1849, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-172, %eax
	movl	%eax, 4(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-8(%ebp), %eax
	jmp	codegen_EmitLogFactor_ret


codegen_EmitLogFactor_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitLogTerm
.type codegen_EmitLogTerm, @function
codegen_EmitLogTerm:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$184, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitLogTerm_reltrue_213
	movl	$0, %eax
codegen_EmitLogTerm_reltrue_213:
	testl	%eax, %eax
	jnz	codegen_EmitLogTerm_ifbl_212
	jmp	codegen_EmitLogTerm_elsebl_212
codegen_EmitLogTerm_ifbl_212:
	#debug: return: return codegen_EmitLogFactor ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogFactor
	addl	$12, %esp
	jmp	codegen_EmitLogTerm_ret
	jmp	codegen_EmitLogTerm_endif_212

codegen_EmitLogTerm_elsebl_212:

codegen_EmitLogTerm_endif_212:

	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: cnt = ( syntax_CountChilds ( tree ) + 1 ) / 2 ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	movl	$2, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	#debug: assignment: idx = 0 ; 
	movl	$0, -4(%ebp)
	#debug: assignment: ret = 0 ; 
	movl	$0, -12(%ebp)
	#debug: assignment: type = 0 ; 
	movl	$0, -20(%ebp)
	#debug: assignment: blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	movl	%eax, -16(%ebp)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: while: idx < cnt 
codegen_EmitLogTerm_while_214:
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	-8(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitLogTerm_reltrue_215
	movl	$0, %eax
codegen_EmitLogTerm_reltrue_215:
	testl	%eax, %eax
	jz	codegen_EmitLogTerm_endwhile_214

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-20(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = codegen_EmitLogFactor ( cg , syntax_GetChild ( tree , 2 * idx ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	$2
	popl	%ebx
	imull	-4(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogFactor
	addl	$12, %esp
	movl	%eax, -20(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -20(%ebp)
	#debug: func-call: codegen_EmitAvoidConstant ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , "\ttestl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+608, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjz\t%s_logtermfalse_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1871, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 1 ; 
	pushl	-4(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -4(%ebp)
	jmp	codegen_EmitLogTerm_while_214
codegen_EmitLogTerm_endwhile_214:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t$1, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1697, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_logtermtrue_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1896, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_logtermfalse_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1921, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$0, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1791, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_logtermtrue_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1943, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-20(%ebp), %eax
	jmp	codegen_EmitLogTerm_ret


codegen_EmitLogTerm_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitLogExpr
.type codegen_EmitLogExpr, @function
codegen_EmitLogExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$184, %esp


	#debug: if: syntax_CountChilds ( tree ) == 1 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitLogExpr_reltrue_217
	movl	$0, %eax
codegen_EmitLogExpr_reltrue_217:
	testl	%eax, %eax
	jnz	codegen_EmitLogExpr_ifbl_216
	jmp	codegen_EmitLogExpr_elsebl_216
codegen_EmitLogExpr_ifbl_216:
	#debug: return: return codegen_EmitLogTerm ( cg , syntax_GetChild ( tree , 0 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogTerm
	addl	$12, %esp
	jmp	codegen_EmitLogExpr_ret
	jmp	codegen_EmitLogExpr_endif_216

codegen_EmitLogExpr_elsebl_216:

codegen_EmitLogExpr_endif_216:

	#debug: assignment: subtree = syntax_GetChild ( tree , 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$1, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: cnt = ( syntax_CountChilds ( tree ) + 1 ) / 2 ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	movl	$2, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	#debug: assignment: idx = 0 ; 
	movl	$0, -4(%ebp)
	#debug: assignment: ret = 0 ; 
	movl	$0, -12(%ebp)
	#debug: assignment: type = 0 ; 
	movl	$0, -20(%ebp)
	#debug: assignment: blocknr = cg -> cntBlocks ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	movl	%eax, -16(%ebp)
	#debug: assignment: cg -> cntBlocks = cg -> cntBlocks + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$24, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: while: idx < cnt 
codegen_EmitLogExpr_while_218:
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	-8(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitLogExpr_reltrue_219
	movl	$0, %eax
codegen_EmitLogExpr_reltrue_219:
	testl	%eax, %eax
	jz	codegen_EmitLogExpr_endwhile_218

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-20(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = codegen_EmitLogTerm ( cg , syntax_GetChild ( tree , 2 * idx ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	$2
	popl	%ebx
	imull	-4(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogTerm
	addl	$12, %esp
	movl	%eax, -20(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -20(%ebp)
	#debug: func-call: codegen_EmitAvoidConstant ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_EmitAvoidConstant
	addl	$8, %esp
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , "\ttestl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+608, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+616, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjnz\t%s_logexprtrue_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1964, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: idx = idx + 1 ; 
	pushl	-4(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -4(%ebp)
	jmp	codegen_EmitLogExpr_while_218
codegen_EmitLogExpr_endwhile_218:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t$0, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1791, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\tjmp\t%s_logexprfalse_%%d\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1989, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_logexprtrue_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2015, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$1, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1697, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "%s_logexprfalse_%%d:\n" , cg -> currFuncName . content ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2036, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$32, %eax
	addl	$16, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( result , tmp , blocknr ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-184, %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return type ; 
	movl	-20(%ebp), %eax
	jmp	codegen_EmitLogExpr_ret


codegen_EmitLogExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , token varname ) 
.globl codegen_EmitVariableAdress
.type codegen_EmitVariableAdress, @function
codegen_EmitVariableAdress:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$168, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: varNode = symbol_FindVariable ( symtab , varname ) ; 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$12, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindVariable
	addl	$148, %esp
	movl	%eax, -8(%ebp)
	#debug: if: varNode == 0 
	pushl	-8(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableAdress_reltrue_221
	movl	$0, %eax
codegen_EmitVariableAdress_reltrue_221:
	testl	%eax, %eax
	jnz	codegen_EmitVariableAdress_ifbl_220
	jmp	codegen_EmitVariableAdress_elsebl_220
codegen_EmitVariableAdress_ifbl_220:
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableAdress_ret
	jmp	codegen_EmitVariableAdress_endif_220

codegen_EmitVariableAdress_elsebl_220:

codegen_EmitVariableAdress_endif_220:

	#debug: if: varNode -> type == 5 
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$5, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableAdress_reltrue_223
	movl	$0, %eax
codegen_EmitVariableAdress_reltrue_223:
	testl	%eax, %eax
	jnz	codegen_EmitVariableAdress_ifbl_222
	jmp	codegen_EmitVariableAdress_elsebl_222
codegen_EmitVariableAdress_ifbl_222:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t$symtab, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2058, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( result , "\taddl\t$%d, %%eax\n" , symbol_GetGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2079, 4(%esp)
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableAdress_endif_222

codegen_EmitVariableAdress_elsebl_222:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t%ebp, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2097, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( result , "\taddl\t$%d, %%eax\n" , symbol_GetNonGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2079, 4(%esp)
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetNonGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-168, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
codegen_EmitVariableAdress_endif_222:

	#debug: return: return varNode -> structure ; 
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	jmp	codegen_EmitVariableAdress_ret


codegen_EmitVariableAdress_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitStartAddrOfNestedVar
.type codegen_EmitStartAddrOfNestedVar, @function
codegen_EmitStartAddrOfNestedVar:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$176, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -32(%ebp)
	#debug: assignment: cntresol = type_CountVarexprResolutions ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CountVarexprResolutions
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: if: subtree -> tok . type != 43 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	jne	codegen_EmitStartAddrOfNestedVar_reltrue_225
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_225:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_224
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_224
codegen_EmitStartAddrOfNestedVar_ifbl_224:
	#debug: assignment: addrop = 1 ; 
	movl	$1, -8(%ebp)
	jmp	codegen_EmitStartAddrOfNestedVar_endif_224

codegen_EmitStartAddrOfNestedVar_elsebl_224:

	#debug: assignment: addrop = 0 ; 
	movl	$0, -8(%ebp)
codegen_EmitStartAddrOfNestedVar_endif_224:

	#debug: assignment: subtree = syntax_GetChild ( tree , addrop ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: assignment: vartype = codegen_EmitVariableAdress ( cg , subtree -> tok ) ; 
	subl	$148, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_EmitVariableAdress
	addl	$148, %esp
	movl	%eax, -28(%ebp)
	#debug: assignment: idx = 1 ; 
	movl	$1, -12(%ebp)
	#debug: if: vartype == 0 
	pushl	-28(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitStartAddrOfNestedVar_reltrue_227
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_227:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_226
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_226
codegen_EmitStartAddrOfNestedVar_ifbl_226:
	#debug: func-call: codegen_reportError ( cg , "Unknown variable." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2115, 4(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret
	jmp	codegen_EmitStartAddrOfNestedVar_endif_226

codegen_EmitStartAddrOfNestedVar_elsebl_226:

codegen_EmitStartAddrOfNestedVar_endif_226:

	#debug: while: idx < cntresol 
codegen_EmitStartAddrOfNestedVar_while_228:
	pushl	-12(%ebp)
	popl	%ebx
	cmpl	-4(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitStartAddrOfNestedVar_reltrue_229
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_229:
	testl	%eax, %eax
	jz	codegen_EmitStartAddrOfNestedVar_endwhile_228

	#debug: if: type_IsAArrayVar ( vartype ) 
	subl	$4, %esp
	movl	-28(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_230
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_230
codegen_EmitStartAddrOfNestedVar_ifbl_230:
	#debug: func-call: codegen_reportError ( cg , "Cannot access array here." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2133, 4(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret
	jmp	codegen_EmitStartAddrOfNestedVar_endif_230

codegen_EmitStartAddrOfNestedVar_elsebl_230:

codegen_EmitStartAddrOfNestedVar_endif_230:

	#debug: assignment: conttype = syntax_GetChild ( syntax_GetChild ( vartype , 0 ) , 0 ) ; 
	subl	$8, %esp
	subl	$8, %esp
	movl	-28(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , addrop + 2 * idx - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-8(%ebp)
	pushl	$2
	popl	%ebx
	imull	-12(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: if: subtree -> tok . type == 10 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$10, %ebx
	movl	$1, %eax
	je	codegen_EmitStartAddrOfNestedVar_reltrue_232
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_232:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_231
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_231
codegen_EmitStartAddrOfNestedVar_ifbl_231:
	#debug: if: syntax_CountChilds ( conttype ) != 2 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$2, %ebx
	movl	$1, %eax
	jne	codegen_EmitStartAddrOfNestedVar_reltrue_234
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_234:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_233
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_233
codegen_EmitStartAddrOfNestedVar_ifbl_233:
	#debug: func-call: codegen_reportError ( cg , "Deref with '->' implies a pointer." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2159, 4(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret
	jmp	codegen_EmitStartAddrOfNestedVar_endif_233

codegen_EmitStartAddrOfNestedVar_elsebl_233:

codegen_EmitStartAddrOfNestedVar_endif_233:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitStartAddrOfNestedVar_endif_231

codegen_EmitStartAddrOfNestedVar_elsebl_231:

	#debug: if: syntax_CountChilds ( conttype ) > 1 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jg	codegen_EmitStartAddrOfNestedVar_reltrue_236
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_236:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_235
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_235
codegen_EmitStartAddrOfNestedVar_ifbl_235:
	#debug: func-call: codegen_reportError ( cg , "Deref with '.' implies non-pointer." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2214, 4(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret
	jmp	codegen_EmitStartAddrOfNestedVar_endif_235

codegen_EmitStartAddrOfNestedVar_elsebl_235:

codegen_EmitStartAddrOfNestedVar_endif_235:

codegen_EmitStartAddrOfNestedVar_endif_231:

	#debug: assignment: subtree = syntax_GetChild ( tree , addrop + 2 * idx ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-8(%ebp)
	pushl	$2
	popl	%ebx
	imull	-12(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: assignment: membername = subtree -> tok ; 
	movl	%ebp, %eax
	addl	$-176, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	#debug: assignment: offset = type_GetMemberOffset ( symtab , conttype , membername ) ; 
	subl	$152, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	type_GetMemberOffset
	addl	$152, %esp
	movl	%eax, -16(%ebp)
	#debug: if: offset < 0 
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_EmitStartAddrOfNestedVar_reltrue_238
	movl	$0, %eax
codegen_EmitStartAddrOfNestedVar_reltrue_238:
	testl	%eax, %eax
	jnz	codegen_EmitStartAddrOfNestedVar_ifbl_237
	jmp	codegen_EmitStartAddrOfNestedVar_elsebl_237
codegen_EmitStartAddrOfNestedVar_ifbl_237:
	#debug: func-call: codegen_reportError ( cg , "Error when accessing member." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2250, 4(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret
	jmp	codegen_EmitStartAddrOfNestedVar_endif_237

codegen_EmitStartAddrOfNestedVar_elsebl_237:

codegen_EmitStartAddrOfNestedVar_endif_237:

	#debug: func-call: sprintf ( result , "\taddl\t$%d, %%eax\n" , offset ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2079, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: vartype = type_GetMemberDeclaration ( symtab , conttype , membername ) ; 
	subl	$152, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-176, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	type_GetMemberDeclaration
	addl	$152, %esp
	movl	%eax, -28(%ebp)
	#debug: assignment: idx = idx + 1 ; 
	pushl	-12(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	codegen_EmitStartAddrOfNestedVar_while_228
codegen_EmitStartAddrOfNestedVar_endwhile_228:

	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return vartype ; 
	movl	-28(%ebp), %eax
	jmp	codegen_EmitStartAddrOfNestedVar_ret


codegen_EmitStartAddrOfNestedVar_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitVarExprAdress
.type codegen_EmitVarExprAdress, @function
codegen_EmitVarExprAdress:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$40, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -40(%ebp)
	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: cntresol = type_CountVarexprResolutions ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CountVarexprResolutions
	addl	$4, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: if: subtree -> tok . type == 4 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitVarExprAdress_reltrue_240
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_240:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_239
	jmp	codegen_EmitVarExprAdress_elsebl_239
codegen_EmitVarExprAdress_ifbl_239:
	#debug: assignment: idxspec = 1 ; 
	movl	$1, -12(%ebp)
	jmp	codegen_EmitVarExprAdress_endif_239

codegen_EmitVarExprAdress_elsebl_239:

	#debug: assignment: idxspec = 0 ; 
	movl	$0, -12(%ebp)
codegen_EmitVarExprAdress_endif_239:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: if: subtree -> tok . type != 43 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	jne	codegen_EmitVarExprAdress_reltrue_242
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_242:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_241
	jmp	codegen_EmitVarExprAdress_elsebl_241
codegen_EmitVarExprAdress_ifbl_241:
	#debug: assignment: addrop = 1 ; 
	movl	$1, -16(%ebp)
	jmp	codegen_EmitVarExprAdress_endif_241

codegen_EmitVarExprAdress_elsebl_241:

	#debug: assignment: addrop = 0 ; 
	movl	$0, -16(%ebp)
codegen_EmitVarExprAdress_endif_241:

	#debug: if: idxspec 
	movl	-12(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_243
	jmp	codegen_EmitVarExprAdress_elsebl_243
codegen_EmitVarExprAdress_ifbl_243:
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , cnt - 2 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -36(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-36(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -36(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVarExprAdress_endif_243

codegen_EmitVarExprAdress_elsebl_243:

codegen_EmitVarExprAdress_endif_243:

	#debug: assignment: vardef = codegen_EmitStartAddrOfNestedVar ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitStartAddrOfNestedVar
	addl	$12, %esp
	movl	%eax, -32(%ebp)
	#debug: if: vardef == 0 
	pushl	-32(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitVarExprAdress_reltrue_245
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_245:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_244
	jmp	codegen_EmitVarExprAdress_elsebl_244
codegen_EmitVarExprAdress_ifbl_244:
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_ret
	jmp	codegen_EmitVarExprAdress_endif_244

codegen_EmitVarExprAdress_elsebl_244:

codegen_EmitVarExprAdress_endif_244:

	#debug: if: type_IsAArrayVar ( vardef ) 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_246
	jmp	codegen_EmitVarExprAdress_elsebl_246
codegen_EmitVarExprAdress_ifbl_246:
	#debug: assignment: isarray = 1 ; 
	movl	$1, -24(%ebp)
	jmp	codegen_EmitVarExprAdress_endif_246

codegen_EmitVarExprAdress_elsebl_246:

	#debug: assignment: isarray = 0 ; 
	movl	$0, -24(%ebp)
codegen_EmitVarExprAdress_endif_246:

	#debug: if: strcmp ( result , "%eax" ) != 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitVarExprAdress_reltrue_248
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_248:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_247
	jmp	codegen_EmitVarExprAdress_elsebl_247
codegen_EmitVarExprAdress_ifbl_247:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVarExprAdress_endif_247

codegen_EmitVarExprAdress_elsebl_247:

codegen_EmitVarExprAdress_endif_247:

	#debug: if: idxspec 
	movl	-12(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_249
	jmp	codegen_EmitVarExprAdress_elsebl_249
codegen_EmitVarExprAdress_ifbl_249:
	#debug: assignment: arrelmsize = type_GetArrayElmSize ( symtab , vardef ) ; 
	subl	$8, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 4(%esp)
	call	type_GetArrayElmSize
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: if: arrelmsize < 0 
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_EmitVarExprAdress_reltrue_251
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_251:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_250
	jmp	codegen_EmitVarExprAdress_elsebl_250
codegen_EmitVarExprAdress_ifbl_250:
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Can't get array-element of expression." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2279, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_ret
	jmp	codegen_EmitVarExprAdress_endif_250

codegen_EmitVarExprAdress_elsebl_250:

codegen_EmitVarExprAdress_endif_250:

	#debug: if: ! isarray 
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitVarExprAdress_logfactfalse_253
	movl	$0, %eax
codegen_EmitVarExprAdress_logfactfalse_253:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_252
	jmp	codegen_EmitVarExprAdress_elsebl_252
codegen_EmitVarExprAdress_ifbl_252:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVarExprAdress_endif_252

codegen_EmitVarExprAdress_elsebl_252:

codegen_EmitVarExprAdress_endif_252:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t%esi\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1346, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: arrelmsize != 1 
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jne	codegen_EmitVarExprAdress_reltrue_255
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_255:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_254
	jmp	codegen_EmitVarExprAdress_elsebl_254
codegen_EmitVarExprAdress_ifbl_254:
	#debug: func-call: sprintf ( result , "\timull\t$%d, %%esi\n" , arrelmsize ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2318, 4(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVarExprAdress_endif_254

codegen_EmitVarExprAdress_elsebl_254:

codegen_EmitVarExprAdress_endif_254:

	#debug: func-call: codegen_emit ( cg , "\taddl\t%esi, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2337, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: type = type_CreateArrayElmType ( vardef ) ; 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateArrayElmType
	addl	$4, %esp
	movl	%eax, -36(%ebp)
	#debug: assignment: isarray = 0 ; 
	movl	$0, -24(%ebp)
	jmp	codegen_EmitVarExprAdress_endif_249

codegen_EmitVarExprAdress_elsebl_249:

	#debug: assignment: type = type_CreateType ( vardef ) ; 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	movl	%eax, -36(%ebp)
codegen_EmitVarExprAdress_endif_249:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: if: subtree -> tok . type == 21 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$21, %ebx
	movl	$1, %eax
	je	codegen_EmitVarExprAdress_reltrue_257
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_257:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_256
	jmp	codegen_EmitVarExprAdress_elsebl_256
codegen_EmitVarExprAdress_ifbl_256:
	#debug: func-call: codegen_reportError ( cg , "Can't get address of variable-expr with address operator.\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2355, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_ret
	jmp	codegen_EmitVarExprAdress_endif_256

codegen_EmitVarExprAdress_elsebl_256:

	#debug: if: subtree -> tok . type == 43 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	je	codegen_EmitVarExprAdress_reltrue_259
	movl	$0, %eax
codegen_EmitVarExprAdress_reltrue_259:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_258
	jmp	codegen_EmitVarExprAdress_elsebl_258
codegen_EmitVarExprAdress_ifbl_258:
	#debug: if: isarray 
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_260
	jmp	codegen_EmitVarExprAdress_elsebl_260
codegen_EmitVarExprAdress_ifbl_260:
	#debug: func-call: codegen_reportError ( cg , "Can't get address of array.\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2414, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_ret
	jmp	codegen_EmitVarExprAdress_endif_260

codegen_EmitVarExprAdress_elsebl_260:

codegen_EmitVarExprAdress_endif_260:

	jmp	codegen_EmitVarExprAdress_endif_258

codegen_EmitVarExprAdress_elsebl_258:

	#debug: if: ! type_IsAPointerType ( type ) || isarray 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitVarExprAdress_logfactfalse_263
	movl	$0, %eax
codegen_EmitVarExprAdress_logfactfalse_263:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_logexprtrue_262
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_logexprtrue_262
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_logexprfalse_262
codegen_EmitVarExprAdress_logexprtrue_262:
	movl	$1, %eax
codegen_EmitVarExprAdress_logexprfalse_262:
	testl	%eax, %eax
	jnz	codegen_EmitVarExprAdress_ifbl_261
	jmp	codegen_EmitVarExprAdress_elsebl_261
codegen_EmitVarExprAdress_ifbl_261:
	#debug: func-call: codegen_reportError ( cg , "Can only de-reference a pointer!\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2443, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVarExprAdress_ret
	jmp	codegen_EmitVarExprAdress_endif_261

codegen_EmitVarExprAdress_elsebl_261:

codegen_EmitVarExprAdress_endif_261:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: subtree = type_RemoveStarFromType ( type ) ; 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_RemoveStarFromType
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = subtree ; 
	movl	-28(%ebp), %eax
	movl	%eax, -36(%ebp)
codegen_EmitVarExprAdress_endif_258:

codegen_EmitVarExprAdress_endif_256:

	#debug: return: return type ; 
	movl	-36(%ebp), %eax
	jmp	codegen_EmitVarExprAdress_ret


codegen_EmitVarExprAdress_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitFastVariableExpr
.type codegen_EmitFastVariableExpr, @function
codegen_EmitFastVariableExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$36, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -36(%ebp)
	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: cntresol = type_CountVarexprResolutions ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CountVarexprResolutions
	addl	$4, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: if: subtree -> tok . type == 4 
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_265
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_265:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_ifbl_264
	jmp	codegen_EmitFastVariableExpr_elsebl_264
codegen_EmitFastVariableExpr_ifbl_264:
	#debug: assignment: idxspec = 1 ; 
	movl	$1, -12(%ebp)
	jmp	codegen_EmitFastVariableExpr_endif_264

codegen_EmitFastVariableExpr_elsebl_264:

	#debug: assignment: idxspec = 0 ; 
	movl	$0, -12(%ebp)
codegen_EmitFastVariableExpr_endif_264:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: if: subtree -> tok . type != 43 
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	jne	codegen_EmitFastVariableExpr_reltrue_267
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_267:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_ifbl_266
	jmp	codegen_EmitFastVariableExpr_elsebl_266
codegen_EmitFastVariableExpr_ifbl_266:
	#debug: assignment: addrop = 1 ; 
	movl	$1, -16(%ebp)
	jmp	codegen_EmitFastVariableExpr_endif_266

codegen_EmitFastVariableExpr_elsebl_266:

	#debug: assignment: addrop = 0 ; 
	movl	$0, -16(%ebp)
codegen_EmitFastVariableExpr_endif_266:

	#debug: assignment: subtree = syntax_GetChild ( tree , addrop ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: varNode = symbol_FindVariable ( symtab , subtree -> tok ) ; 
	subl	$148, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindVariable
	addl	$148, %esp
	movl	%eax, -20(%ebp)
	#debug: if: varNode == 0 
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_269
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_269:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_ifbl_268
	jmp	codegen_EmitFastVariableExpr_elsebl_268
codegen_EmitFastVariableExpr_ifbl_268:
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFastVariableExpr_ret
	jmp	codegen_EmitFastVariableExpr_endif_268

codegen_EmitFastVariableExpr_elsebl_268:

codegen_EmitFastVariableExpr_endif_268:

	#debug: assignment: vardef = varNode -> structure ; 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, -28(%ebp)
	#debug: assignment: type = type_CreateType ( varNode -> structure ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	movl	%eax, -32(%ebp)
	#debug: if: addrop == 0 && idxspec == 0 && cntresol == 1 && ! type_IsAArrayVar ( vardef ) && ! type_IsAStructType ( type ) 
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_272
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_272:
	testl	%eax, %eax
	jz	codegen_EmitFastVariableExpr_logtermfalse_271
	pushl	-12(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_273
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_273:
	testl	%eax, %eax
	jz	codegen_EmitFastVariableExpr_logtermfalse_271
	pushl	-8(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_274
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_274:
	testl	%eax, %eax
	jz	codegen_EmitFastVariableExpr_logtermfalse_271
	subl	$4, %esp
	movl	-28(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitFastVariableExpr_logfactfalse_275
	movl	$0, %eax
codegen_EmitFastVariableExpr_logfactfalse_275:
	testl	%eax, %eax
	jz	codegen_EmitFastVariableExpr_logtermfalse_271
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitFastVariableExpr_logfactfalse_276
	movl	$0, %eax
codegen_EmitFastVariableExpr_logfactfalse_276:
	testl	%eax, %eax
	jz	codegen_EmitFastVariableExpr_logtermfalse_271
	movl	$1, %eax
	jmp	codegen_EmitFastVariableExpr_logtermtrue_271
codegen_EmitFastVariableExpr_logtermfalse_271:
	movl	$0, %eax
codegen_EmitFastVariableExpr_logtermtrue_271:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_ifbl_270
	jmp	codegen_EmitFastVariableExpr_elsebl_270
codegen_EmitFastVariableExpr_ifbl_270:
	#debug: if: varNode -> type == 6 || varNode -> type == 4 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$6, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_279
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_279:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_logexprtrue_278
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$144, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitFastVariableExpr_reltrue_280
	movl	$0, %eax
codegen_EmitFastVariableExpr_reltrue_280:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_logexprtrue_278
	movl	$0, %eax
	jmp	codegen_EmitFastVariableExpr_logexprfalse_278
codegen_EmitFastVariableExpr_logexprtrue_278:
	movl	$1, %eax
codegen_EmitFastVariableExpr_logexprfalse_278:
	testl	%eax, %eax
	jnz	codegen_EmitFastVariableExpr_ifbl_277
	jmp	codegen_EmitFastVariableExpr_elsebl_277
codegen_EmitFastVariableExpr_ifbl_277:
	#debug: func-call: sprintf ( result , "%d(%%ebp)" , symbol_GetNonGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1318, 4(%esp)
	subl	$8, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetNonGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	jmp	codegen_EmitFastVariableExpr_endif_277

codegen_EmitFastVariableExpr_elsebl_277:

	#debug: func-call: sprintf ( result , "symtab+%d" , symbol_GetGlobalOffset ( symtab , varNode ) ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1328, 4(%esp)
	subl	$8, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetGlobalOffset
	addl	$8, %esp
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
codegen_EmitFastVariableExpr_endif_277:

	#debug: return: return type ; 
	movl	-32(%ebp), %eax
	jmp	codegen_EmitFastVariableExpr_ret
	jmp	codegen_EmitFastVariableExpr_endif_270

codegen_EmitFastVariableExpr_elsebl_270:

codegen_EmitFastVariableExpr_endif_270:

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFastVariableExpr_ret


codegen_EmitFastVariableExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitVariableExpr
.type codegen_EmitVariableExpr, @function
codegen_EmitVariableExpr:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$40, %esp


	#debug: if: cg -> enOptFastassign 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$16, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_281
	jmp	codegen_EmitVariableExpr_elsebl_281
codegen_EmitVariableExpr_ifbl_281:
	#debug: assignment: subtree = codegen_EmitFastVariableExpr ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitFastVariableExpr
	addl	$12, %esp
	movl	%eax, -28(%ebp)
	#debug: if: subtree != 0 
	pushl	-28(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitVariableExpr_reltrue_283
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_283:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_282
	jmp	codegen_EmitVariableExpr_elsebl_282
codegen_EmitVariableExpr_ifbl_282:
	#debug: return: return subtree ; 
	movl	-28(%ebp), %eax
	jmp	codegen_EmitVariableExpr_ret
	jmp	codegen_EmitVariableExpr_endif_282

codegen_EmitVariableExpr_elsebl_282:

codegen_EmitVariableExpr_endif_282:

	jmp	codegen_EmitVariableExpr_endif_281

codegen_EmitVariableExpr_elsebl_281:

codegen_EmitVariableExpr_endif_281:

	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -40(%ebp)
	#debug: assignment: cnt = syntax_CountChilds ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: cntresol = type_CountVarexprResolutions ( tree ) ; 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CountVarexprResolutions
	addl	$4, %esp
	movl	%eax, -8(%ebp)
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: if: subtree -> tok . type == 4 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$4, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableExpr_reltrue_285
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_285:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_284
	jmp	codegen_EmitVariableExpr_elsebl_284
codegen_EmitVariableExpr_ifbl_284:
	#debug: assignment: idxspec = 1 ; 
	movl	$1, -12(%ebp)
	jmp	codegen_EmitVariableExpr_endif_284

codegen_EmitVariableExpr_elsebl_284:

	#debug: assignment: idxspec = 0 ; 
	movl	$0, -12(%ebp)
codegen_EmitVariableExpr_endif_284:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: if: subtree -> tok . type != 43 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	jne	codegen_EmitVariableExpr_reltrue_287
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_287:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_286
	jmp	codegen_EmitVariableExpr_elsebl_286
codegen_EmitVariableExpr_ifbl_286:
	#debug: assignment: addrop = 1 ; 
	movl	$1, -16(%ebp)
	jmp	codegen_EmitVariableExpr_endif_286

codegen_EmitVariableExpr_elsebl_286:

	#debug: assignment: addrop = 0 ; 
	movl	$0, -16(%ebp)
codegen_EmitVariableExpr_endif_286:

	#debug: if: idxspec 
	movl	-12(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_288
	jmp	codegen_EmitVariableExpr_elsebl_288
codegen_EmitVariableExpr_ifbl_288:
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , cnt - 2 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -36(%ebp)
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-36(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -36(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: func-call: codegen_emit ( cg , "\tpushl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1338, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_288

codegen_EmitVariableExpr_elsebl_288:

codegen_EmitVariableExpr_endif_288:

	#debug: assignment: vardef = codegen_EmitStartAddrOfNestedVar ( cg , tree , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitStartAddrOfNestedVar
	addl	$12, %esp
	movl	%eax, -32(%ebp)
	#debug: if: vardef == 0 
	pushl	-32(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableExpr_reltrue_290
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_290:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_289
	jmp	codegen_EmitVariableExpr_elsebl_289
codegen_EmitVariableExpr_ifbl_289:
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
	jmp	codegen_EmitVariableExpr_endif_289

codegen_EmitVariableExpr_elsebl_289:

codegen_EmitVariableExpr_endif_289:

	#debug: if: type_IsAArrayVar ( vardef ) 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAArrayVar
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_291
	jmp	codegen_EmitVariableExpr_elsebl_291
codegen_EmitVariableExpr_ifbl_291:
	#debug: assignment: isarray = 1 ; 
	movl	$1, -24(%ebp)
	jmp	codegen_EmitVariableExpr_endif_291

codegen_EmitVariableExpr_elsebl_291:

	#debug: assignment: isarray = 0 ; 
	movl	$0, -24(%ebp)
codegen_EmitVariableExpr_endif_291:

	#debug: if: strcmp ( result , "%eax" ) != 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	codegen_EmitVariableExpr_reltrue_293
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_293:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_292
	jmp	codegen_EmitVariableExpr_elsebl_292
codegen_EmitVariableExpr_ifbl_292:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+201, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , ", %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+208, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_292

codegen_EmitVariableExpr_elsebl_292:

codegen_EmitVariableExpr_endif_292:

	#debug: if: idxspec 
	movl	-12(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_294
	jmp	codegen_EmitVariableExpr_elsebl_294
codegen_EmitVariableExpr_ifbl_294:
	#debug: assignment: arrelmsize = type_GetArrayElmSize ( symtab , vardef ) ; 
	subl	$8, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-32(%ebp), %eax
	movl	%eax, 4(%esp)
	call	type_GetArrayElmSize
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: if: arrelmsize < 0 
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jl	codegen_EmitVariableExpr_reltrue_296
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_296:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_295
	jmp	codegen_EmitVariableExpr_elsebl_295
codegen_EmitVariableExpr_ifbl_295:
	#debug: assignment: subtree = syntax_GetChild ( tree , cnt - 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	-4(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: codegen_reportError ( cg , "Can't get array-element of expression." , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2279, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
	jmp	codegen_EmitVariableExpr_endif_295

codegen_EmitVariableExpr_elsebl_295:

codegen_EmitVariableExpr_endif_295:

	#debug: if: ! isarray 
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitVariableExpr_logfactfalse_298
	movl	$0, %eax
codegen_EmitVariableExpr_logfactfalse_298:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_297
	jmp	codegen_EmitVariableExpr_elsebl_297
codegen_EmitVariableExpr_ifbl_297:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_297

codegen_EmitVariableExpr_elsebl_297:

codegen_EmitVariableExpr_endif_297:

	#debug: func-call: codegen_emit ( cg , "\tpopl\t%esi\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1346, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: if: arrelmsize != 1 
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jne	codegen_EmitVariableExpr_reltrue_300
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_300:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_299
	jmp	codegen_EmitVariableExpr_elsebl_299
codegen_EmitVariableExpr_ifbl_299:
	#debug: func-call: sprintf ( result , "\timull\t$%d, %%esi\n" , arrelmsize ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2318, 4(%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_299

codegen_EmitVariableExpr_elsebl_299:

codegen_EmitVariableExpr_endif_299:

	#debug: func-call: codegen_emit ( cg , "\taddl\t%esi, %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2337, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: type = type_CreateArrayElmType ( vardef ) ; 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateArrayElmType
	addl	$4, %esp
	movl	%eax, -36(%ebp)
	#debug: assignment: isarray = 0 ; 
	movl	$0, -24(%ebp)
	jmp	codegen_EmitVariableExpr_endif_294

codegen_EmitVariableExpr_elsebl_294:

	#debug: assignment: type = type_CreateType ( vardef ) ; 
	subl	$4, %esp
	movl	-32(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	movl	%eax, -36(%ebp)
codegen_EmitVariableExpr_endif_294:

	#debug: assignment: subtree = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: if: subtree -> tok . type == 21 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$21, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableExpr_reltrue_302
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_302:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_301
	jmp	codegen_EmitVariableExpr_elsebl_301
codegen_EmitVariableExpr_ifbl_301:
	#debug: if: isarray 
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_303
	jmp	codegen_EmitVariableExpr_elsebl_303
codegen_EmitVariableExpr_ifbl_303:
	#debug: func-call: codegen_reportError ( cg , "Can't get address of an array, only from elements.\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2477, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
	jmp	codegen_EmitVariableExpr_endif_303

codegen_EmitVariableExpr_elsebl_303:

codegen_EmitVariableExpr_endif_303:

	#debug: assignment: subtree = type_AddStarToType ( type ) ; 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_AddStarToType
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = subtree ; 
	movl	-28(%ebp), %eax
	movl	%eax, -36(%ebp)
	jmp	codegen_EmitVariableExpr_endif_301

codegen_EmitVariableExpr_elsebl_301:

	#debug: if: subtree -> tok . type == 43 
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$0, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$43, %ebx
	movl	$1, %eax
	je	codegen_EmitVariableExpr_reltrue_305
	movl	$0, %eax
codegen_EmitVariableExpr_reltrue_305:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_304
	jmp	codegen_EmitVariableExpr_elsebl_304
codegen_EmitVariableExpr_ifbl_304:
	#debug: if: isarray 
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_306
	jmp	codegen_EmitVariableExpr_elsebl_306
codegen_EmitVariableExpr_ifbl_306:
	#debug: assignment: subtree = type_AddStarToType ( type ) ; 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_AddStarToType
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = subtree ; 
	movl	-28(%ebp), %eax
	movl	%eax, -36(%ebp)
	jmp	codegen_EmitVariableExpr_endif_306

codegen_EmitVariableExpr_elsebl_306:

	#debug: if: type_IsAStructType ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_307
	jmp	codegen_EmitVariableExpr_elsebl_307
codegen_EmitVariableExpr_ifbl_307:
	jmp	codegen_EmitVariableExpr_endif_307

codegen_EmitVariableExpr_elsebl_307:

	#debug: if: type_IsLongSized ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_308
	jmp	codegen_EmitVariableExpr_elsebl_308
codegen_EmitVariableExpr_ifbl_308:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_308

codegen_EmitVariableExpr_elsebl_308:

	#debug: if: type_IsByteSized ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_309
	jmp	codegen_EmitVariableExpr_elsebl_309
codegen_EmitVariableExpr_ifbl_309:
	#debug: func-call: codegen_emit ( cg , "\tmovb\t(%eax), %al\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2529, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%al" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2548, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_309

codegen_EmitVariableExpr_elsebl_309:

	#debug: func-call: codegen_reportError ( cg , "Internal Error: Unhandled case in codegen_EmitVariableExpr!\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2552, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
codegen_EmitVariableExpr_endif_309:

codegen_EmitVariableExpr_endif_308:

codegen_EmitVariableExpr_endif_307:

codegen_EmitVariableExpr_endif_306:

	jmp	codegen_EmitVariableExpr_endif_304

codegen_EmitVariableExpr_elsebl_304:

	#debug: if: ! type_IsAPointerType ( type ) || isarray 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAPointerType
	addl	$4, %esp
	testl	%eax, %eax
	movl	$1, %eax
	jz	codegen_EmitVariableExpr_logfactfalse_312
	movl	$0, %eax
codegen_EmitVariableExpr_logfactfalse_312:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_logexprtrue_311
	movl	-24(%ebp), %eax
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_logexprtrue_311
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_logexprfalse_311
codegen_EmitVariableExpr_logexprtrue_311:
	movl	$1, %eax
codegen_EmitVariableExpr_logexprfalse_311:
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_310
	jmp	codegen_EmitVariableExpr_elsebl_310
codegen_EmitVariableExpr_ifbl_310:
	#debug: func-call: codegen_reportError ( cg , "Can only de-reference a pointer!\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2443, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
	jmp	codegen_EmitVariableExpr_endif_310

codegen_EmitVariableExpr_elsebl_310:

codegen_EmitVariableExpr_endif_310:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: subtree = type_RemoveStarFromType ( type ) ; 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_RemoveStarFromType
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: type = subtree ; 
	movl	-28(%ebp), %eax
	movl	%eax, -36(%ebp)
	#debug: if: type_IsAStructType ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_313
	jmp	codegen_EmitVariableExpr_elsebl_313
codegen_EmitVariableExpr_ifbl_313:
	jmp	codegen_EmitVariableExpr_endif_313

codegen_EmitVariableExpr_elsebl_313:

	#debug: if: type_IsLongSized ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_314
	jmp	codegen_EmitVariableExpr_elsebl_314
codegen_EmitVariableExpr_ifbl_314:
	#debug: func-call: codegen_emit ( cg , "\tmovl\t(%eax), %eax\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2194, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_314

codegen_EmitVariableExpr_elsebl_314:

	#debug: if: type_IsByteSized ( type ) 
	subl	$4, %esp
	movl	-36(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitVariableExpr_ifbl_315
	jmp	codegen_EmitVariableExpr_elsebl_315
codegen_EmitVariableExpr_ifbl_315:
	#debug: func-call: codegen_emit ( cg , "\tmovb\t(%eax), %al\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2529, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%al" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2548, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitVariableExpr_endif_315

codegen_EmitVariableExpr_elsebl_315:

	#debug: func-call: codegen_reportError ( cg , "Internal Error: Unhandled case in codegen_EmitVariableExpr!\n" , subtree -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2552, 4(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitVariableExpr_ret
codegen_EmitVariableExpr_endif_315:

codegen_EmitVariableExpr_endif_314:

codegen_EmitVariableExpr_endif_313:

codegen_EmitVariableExpr_endif_304:

codegen_EmitVariableExpr_endif_301:

	#debug: return: return type ; 
	movl	-36(%ebp), %eax
	jmp	codegen_EmitVariableExpr_ret


codegen_EmitVariableExpr_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( codegen * cg , syntaxTreeNode * tree , char * result ) 
.globl codegen_EmitFuncCall
.type codegen_EmitFuncCall, @function
codegen_EmitFuncCall:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$528, %esp


	#debug: assignment: symtab = cg -> parse -> symTable ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20, %eax
	movl	(%eax), %eax
	addl	$4, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	#debug: assignment: funcname = syntax_GetChild ( tree , 0 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -12(%ebp)
	#debug: assignment: node = symbol_FindFunction ( symtab , funcname -> tok ) ; 
	subl	$148, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	symbol_FindFunction
	addl	$148, %esp
	movl	%eax, -8(%ebp)
	#debug: if: node == 0 
	pushl	-8(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFuncCall_reltrue_317
	movl	$0, %eax
codegen_EmitFuncCall_reltrue_317:
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_316
	jmp	codegen_EmitFuncCall_elsebl_316
codegen_EmitFuncCall_ifbl_316:
	#debug: func-call: codegen_reportError ( cg , "Calling unknown function." , funcname -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2613, 4(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFuncCall_ret
	jmp	codegen_EmitFuncCall_endif_316

codegen_EmitFuncCall_elsebl_316:

codegen_EmitFuncCall_endif_316:

	#debug: assignment: argsizesum = symbol_Sizeof_FunctionArgs ( symtab , node -> structure ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_FunctionArgs
	addl	$8, %esp
	movl	%eax, -36(%ebp)
	#debug: func-call: sprintf ( result , "\tsubl\t$%d, %%esp\n" , argsizesum ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+534, 4(%esp)
	movl	-36(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: assignment: offset = 0 ; 
	movl	$0, -40(%ebp)
	#debug: assignment: idx = 0 ; 
	movl	$0, -44(%ebp)
	#debug: assignment: cnt = symbol_CountFunctionArgs ( symtab , node -> structure ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	symbol_CountFunctionArgs
	addl	$8, %esp
	movl	%eax, -48(%ebp)
	#debug: if: ( syntax_CountChilds ( tree ) - 2 ) / 2 != cnt 
	subl	$4, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_CountChilds
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	subl	$2, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	movl	$2, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ebx
	cmpl	-48(%ebp), %ebx
	movl	$1, %eax
	jne	codegen_EmitFuncCall_reltrue_319
	movl	$0, %eax
codegen_EmitFuncCall_reltrue_319:
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_318
	jmp	codegen_EmitFuncCall_elsebl_318
codegen_EmitFuncCall_ifbl_318:
	#debug: func-call: codegen_reportError ( cg , "Invalid argument number!" , funcname -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2639, 4(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	codegen_EmitFuncCall_ret
	jmp	codegen_EmitFuncCall_endif_318

codegen_EmitFuncCall_elsebl_318:

codegen_EmitFuncCall_endif_318:

	#debug: while: idx < cnt 
codegen_EmitFuncCall_while_320:
	pushl	-44(%ebp)
	popl	%ebx
	cmpl	-48(%ebp), %ebx
	movl	$1, %eax
	jl	codegen_EmitFuncCall_reltrue_321
	movl	$0, %eax
codegen_EmitFuncCall_reltrue_321:
	testl	%eax, %eax
	jz	codegen_EmitFuncCall_endwhile_320

	#debug: assignment: argtype = symbol_GetFunctionArg ( symtab , node -> structure , idx ) ; 
	subl	$12, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	movl	-44(%ebp), %eax
	movl	%eax, 8(%esp)
	call	symbol_GetFunctionArg
	addl	$12, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: argtype = syntax_GetChild ( syntax_GetChild ( argtype , 0 ) , 0 ) ; 
	subl	$8, %esp
	subl	$8, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: type = codegen_EmitLogExpr ( cg , syntax_GetChild ( tree , 2 * idx + 2 ) , result ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	$2
	popl	%ebx
	imull	-44(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	popl	%ebx
	addl	$2, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitLogExpr
	addl	$12, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: codegen_EmitAvoidIndirect ( cg , result , type ) 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 8(%esp)
	call	codegen_EmitAvoidIndirect
	addl	$12, %esp
	#debug: assignment: subtree = syntax_GetChild ( tree , 2 * idx + 1 ) ; 
	subl	$8, %esp
	movl	12(%ebp), %eax
	movl	%eax, 0(%esp)
	pushl	$2
	popl	%ebx
	imull	-44(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 4(%esp)
	call	syntax_GetChild
	addl	$8, %esp
	movl	%eax, -32(%ebp)
	#debug: func-call: codegen_CheckCasting ( cg , argtype , type , subtree -> tok ) 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-32, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$12, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_CheckCasting
	addl	$156, %esp
	#debug: if: type_IsLongSized ( argtype ) 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsLongSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_322
	jmp	codegen_EmitFuncCall_elsebl_322
codegen_EmitFuncCall_ifbl_322:
	#debug: assignment: type = codegen_CastToInt ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-32, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToInt
	addl	$156, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: sprintf ( tmp , "\tmovl\t%%s, %d(%%%%esp)\n" , offset ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2664, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( tmpres , tmp , result ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , tmpres ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFuncCall_endif_322

codegen_EmitFuncCall_elsebl_322:

	#debug: if: type_IsByteSized ( argtype ) 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_323
	jmp	codegen_EmitFuncCall_elsebl_323
codegen_EmitFuncCall_ifbl_323:
	#debug: assignment: type = codegen_CastToChar ( cg , subtree -> tok , result , type ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-32, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -28(%ebp)
	#debug: func-call: sprintf ( tmp , "\tmovb\t%%s, %d(%%%%esp)\n" , offset ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2688, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( tmpres , tmp , result ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , tmpres ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	jmp	codegen_EmitFuncCall_endif_323

codegen_EmitFuncCall_elsebl_323:

	#debug: if: type_IsAStructType ( argtype ) 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsAStructType
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_324
	jmp	codegen_EmitFuncCall_elsebl_324
codegen_EmitFuncCall_ifbl_324:
	#debug: if: strcmp ( result , "%eax" ) == 0 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcmp
	addl	$8, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	codegen_EmitFuncCall_reltrue_326
	movl	$0, %eax
codegen_EmitFuncCall_reltrue_326:
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_325
	jmp	codegen_EmitFuncCall_elsebl_325
codegen_EmitFuncCall_ifbl_325:
	#debug: func-call: strcpy ( tmpres , "%ebx" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+1200, 4(%esp)
	call	strcpy
	addl	$8, %esp
	jmp	codegen_EmitFuncCall_endif_325

codegen_EmitFuncCall_elsebl_325:

	#debug: func-call: strcpy ( tmpres , "%eax" ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
codegen_EmitFuncCall_endif_325:

	#debug: func-call: codegen_emit ( cg , "\tmovl\t%esp, " ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2712, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , tmpres ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( tmp , "\taddl\t$%d, %%s\n" , offset ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2725, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: sprintf ( tmpres2 , tmp , tmpres ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-368, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-528, %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , tmpres2 ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-368, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_EmitCopyJunk ( cg , tmpres , result , symbol_Sizeof_DataType ( symtab , argtype ) ) 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-208, %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_DataType
	addl	$8, %esp
	movl	%eax, 12(%esp)
	call	codegen_EmitCopyJunk
	addl	$16, %esp
	jmp	codegen_EmitFuncCall_endif_324

codegen_EmitFuncCall_elsebl_324:

	#debug: func-call: codegen_reportError ( cg , "Internal Error: Unhandled case in function call.\n" , funcname -> tok ) 
	subl	$152, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2741, 4(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$8, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	call	codegen_reportError
	addl	$152, %esp
codegen_EmitFuncCall_endif_324:

codegen_EmitFuncCall_endif_323:

codegen_EmitFuncCall_endif_322:

	#debug: func-call: syntax_FreeSyntaxTree ( type ) 
	subl	$4, %esp
	movl	-28(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	#debug: assignment: offset = offset + symbol_Sizeof_DataType ( symtab , argtype ) ; 
	pushl	-40(%ebp)
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	call	symbol_Sizeof_DataType
	addl	$8, %esp
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -40(%ebp)
	#debug: assignment: idx = idx + 1 ; 
	pushl	-44(%ebp)
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, -44(%ebp)
	jmp	codegen_EmitFuncCall_while_320
codegen_EmitFuncCall_endwhile_320:

	#debug: func-call: codegen_emit ( cg , "\tcall\t" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2791, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , funcname -> tok . content ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	addl	$16, %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: codegen_emit ( cg , "\n" ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+198, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: sprintf ( result , "\taddl\t$%d, %%esp\n" , argsizesum ) 
	subl	$12, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+2798, 4(%esp)
	movl	-36(%ebp), %eax
	movl	%eax, 8(%esp)
	call	sprintf
	addl	$12, %esp
	#debug: func-call: codegen_emit ( cg , result ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	call	codegen_emit
	addl	$8, %esp
	#debug: func-call: strcpy ( result , "%eax" ) 
	subl	$8, %esp
	movl	16(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+216, 4(%esp)
	call	strcpy
	addl	$8, %esp
	#debug: assignment: rettype = symbol_GetReturnType ( symtab , node -> structure ) ; 
	subl	$8, %esp
	movl	-4(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	call	symbol_GetReturnType
	addl	$8, %esp
	movl	%eax, -20(%ebp)
	#debug: if: type_IsByteSized ( rettype ) 
	subl	$4, %esp
	movl	-20(%ebp), %eax
	movl	%eax, 0(%esp)
	call	type_IsByteSized
	addl	$4, %esp
	testl	%eax, %eax
	jnz	codegen_EmitFuncCall_ifbl_327
	jmp	codegen_EmitFuncCall_elsebl_327
codegen_EmitFuncCall_ifbl_327:
	#debug: assignment: dummytype = codegen_CreateIntType ( ) ; 
	subl	$0, %esp
	call	codegen_CreateIntType
	addl	$0, %esp
	movl	%eax, -16(%ebp)
	#debug: assignment: dummytype = codegen_CastToChar ( cg , funcname -> tok , result , dummytype ) ; 
	subl	$156, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	(%eax), %eax
	addl	$8, %eax
	movl	%esp, %ebx
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	16(%ebp), %eax
	movl	%eax, 148(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 152(%esp)
	call	codegen_CastToChar
	addl	$156, %esp
	movl	%eax, -16(%ebp)
	#debug: func-call: syntax_FreeSyntaxTree ( dummytype ) 
	subl	$4, %esp
	movl	-16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	syntax_FreeSyntaxTree
	addl	$4, %esp
	jmp	codegen_EmitFuncCall_endif_327

codegen_EmitFuncCall_elsebl_327:

codegen_EmitFuncCall_endif_327:

	#debug: return: return type_CreateType ( node -> structure ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	(%eax), %eax
	addl	$148, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	type_CreateType
	addl	$4, %esp
	jmp	codegen_EmitFuncCall_ret


codegen_EmitFuncCall_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




# The symbol table 

.section .data
symtab:
	.string	"CODEGEN_ERROR: %d, "
	.string	"%d, "
	.string	"%s:\n"
	.string	"[ERR filename] (%p)\n"
	.string	"\tToken is '%s' ::   "
	.string	"%s\n"
	.string	"CODEGEN_WARNING: %s"
	.string	" Token is %d"
	.string	", %s"
	.string	" @ %d"
	.string	",%d, "
	.string	"[ERR filename]\n"
	.string	"CODEGEN_ERROR: Error emitting code to file!"
	.string	" "
	.string	"\t#debug: "
	.string	"\n"
	.string	""
	.string	"\tmovl\t"
	.string	", %eax\n"
	.string	"%eax"
	.string	"\tmovb\t"
	.string	", %ah\n"
	.string	"%ah"
	.string	"# gas-assembler code generated by HrwCC\n\n"
	.string	".section .text\n"
	.string	"# The symbol table \n\n"
	.string	".section .data\n"
	.string	"symtab:\n"
	.string	"\t.string\t"
	.string	"global-var: "
	.string	"\t.rept %d\n"
	.string	"\t\t.byte 0\n"
	.string	"\t.endr\n"
	.string	"\t.long 0\n"
	.string	"\t.byte 0\n"
	.string	"struct: %d\n"
	.string	"\tunknown type of symtab-entry!\n"
	.string	"func-def: "
	.string	".globl "
	.string	".type "
	.string	", @function\n"
	.string	":\n"
	.string	"\tpushl\t%ebp\n"
	.string	"\tmovl\t%esp, %ebp\n"
	.string	"\tsubl\t$%d, %%esp\n"
	.string	"\n\n"
	.string	"_ret:\n"
	.string	"\tmovl\t%ebp, %esp\n"
	.string	"\tpopl\t%ebp\n"
	.string	"\tret\n"
	.string	"\n\n\n\n"
	.string	"if: "
	.string	"\ttestl\t"
	.string	", "
	.string	"\tjnz\t%s_ifbl_%%d\n"
	.string	"\tjmp\t%s_elsebl_%%d\n"
	.string	"%s_ifbl_%%d:\n"
	.string	"\tjmp\t%s_endif_%%d\n\n"
	.string	"%s_elsebl_%%d:\n\n"
	.string	"%s_endif_%%d:\n\n"
	.string	"while: "
	.string	"%s_while_%%d:\n"
	.string	"\tjz\t%s_endwhile_%%d\n\n"
	.string	"\tjmp\t%s_while_%%d\n"
	.string	"%s_endwhile_%%d:\n\n"
	.string	"Detected a break-statement which is not bounded by a while."
	.string	"\tjmp\t%s_endwhile_%%d\n"
	.string	"Detected a continue-statement which is not bounded by a while."
	.string	"return: "
	.string	"Return-type of struct-instance is not supported.\n"
	.string	"\tjmp\t%s_ret\n"
	.string	"Non-void return-typed functions need return value!"
	.string	"func-call: "
	.string	"Pointer types must be equal or one of both is void* typed."
	.string	"Casting between struct-instances not allowed."
	.string	", %ebx\n"
	.string	"%ebx"
	.string	"%ecx"
	.string	"\tmovl\t("
	.string	"), "
	.string	", ("
	.string	")\n"
	.string	"\taddl\t$4, "
	.string	"\tmovb\t("
	.string	"\taddl\t$1, "
	.string	"Unknown variable.\n"
	.string	"Internal compiler error: EmitFastAssign"
	.string	"%d(%%ebp)"
	.string	"symtab+%d"
	.string	"\tpushl\t"
	.string	"\tpopl\t%esi\n"
	.string	"%d"
	.string	"(%%ebp, %%esi, %d)\n"
	.string	"(, %%esi, %d)\n"
	.string	"assignment: "
	.string	"ebx"
	.string	"\tpopl\t"
	.string	"Internal Error: Unhandled case in assignment."
	.string	"int"
	.string	"char"
	.string	"void"
	.string	"*"
	.string	"\tmovsbl\t"
	.string	"Can not cast to int."
	.string	"%Xl"
	.string	"Can not cast to char."
	.string	"$%d"
	.string	"$symtab+%d"
	.string	"\tnotl\t%eax\n"
	.string	"\tpopl\t%eax\n"
	.string	"\tmovl\t$0, %edx\n"
	.string	"\tidivl\t"
	.string	"%edx"
	.string	"\tandl\t"
	.string	"\txorl\t"
	.string	"\timull\t"
	.string	"\tpushl\t$0\n"
	.string	"\tmovl\t$%d, %%esi\n"
	.string	", %esi\n"
	.string	"%esi"
	.string	"\taddl\t"
	.string	"\tsubl\t"
	.string	"\torl\t"
	.string	"\tcmpl\t"
	.string	"\tmovl\t$1, %eax\n"
	.string	"\tje\t"
	.string	"\tjne\t"
	.string	"\tjl\t"
	.string	"\tjle\t"
	.string	"\tjg\t"
	.string	"\tjge\t"
	.string	"Unknown relational operator."
	.string	"%s_reltrue_%%d\n"
	.string	"\tmovl\t$0, %eax\n"
	.string	"%s_reltrue_%%d:\n"
	.string	"\tjz\t%s_logfactfalse_%%d\n"
	.string	"%s_logfactfalse_%%d:\n"
	.string	"\tjz\t%s_logtermfalse_%%d\n"
	.string	"\tjmp\t%s_logtermtrue_%%d\n"
	.string	"%s_logtermfalse_%%d:\n"
	.string	"%s_logtermtrue_%%d:\n"
	.string	"\tjnz\t%s_logexprtrue_%%d\n"
	.string	"\tjmp\t%s_logexprfalse_%%d\n"
	.string	"%s_logexprtrue_%%d:\n"
	.string	"%s_logexprfalse_%%d:\n"
	.string	"\tmovl\t$symtab, %eax\n"
	.string	"\taddl\t$%d, %%eax\n"
	.string	"\tmovl\t%ebp, %eax\n"
	.string	"Unknown variable."
	.string	"Cannot access array here."
	.string	"Deref with '->' implies a pointer."
	.string	"\tmovl\t(%eax), %eax\n"
	.string	"Deref with '.' implies non-pointer."
	.string	"Error when accessing member."
	.string	"Can't get array-element of expression."
	.string	"\timull\t$%d, %%esi\n"
	.string	"\taddl\t%esi, %eax\n"
	.string	"Can't get address of variable-expr with address operator.\n"
	.string	"Can't get address of array.\n"
	.string	"Can only de-reference a pointer!\n"
	.string	"Can't get address of an array, only from elements.\n"
	.string	"\tmovb\t(%eax), %al\n"
	.string	"%al"
	.string	"Internal Error: Unhandled case in codegen_EmitVariableExpr!\n"
	.string	"Calling unknown function."
	.string	"Invalid argument number!"
	.string	"\tmovl\t%%s, %d(%%%%esp)\n"
	.string	"\tmovb\t%%s, %d(%%%%esp)\n"
	.string	"\tmovl\t%esp, "
	.string	"\taddl\t$%d, %%s\n"
	.string	"Internal Error: Unhandled case in function call.\n"
	.string	"\tcall\t"
	.string	"\taddl\t$%d, %%esp\n"

