# gas-assembler code generated by HrwCC

.section .text
	#debug: func-def: ( preproc * instance ) 
.globl substage_init
.type substage_init, @function
substage_init:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: func-call: initLine ( & instance -> substage ) 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$14036, %eax
	movl	%eax, 0(%esp)
	call	initLine
	addl	$4, %esp
	#debug: assignment: instance -> replacement = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20712, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> replacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> paramReplacement = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> paramReplacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	substage_init_ret


substage_init_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( preproc * instance ) 
.globl substage_destroy
.type substage_destroy, @function
substage_destroy:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$0, %esp


	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	substage_destroy_ret


substage_destroy_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( Character * buffer , int buffer_length , int pos , int * offset ) 
.globl isBufferPosMacroBegin
.type isBufferPosMacroBegin, @function
isBufferPosMacroBegin:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$13, %esp


	#debug: if: pos == 0 || pos == buffer_length 
	pushl	16(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	isBufferPosMacroBegin_reltrue_2
	movl	$0, %eax
isBufferPosMacroBegin_reltrue_2:
	testl	%eax, %eax
	jnz	isBufferPosMacroBegin_logexprtrue_1
	pushl	16(%ebp)
	popl	%ebx
	cmpl	12(%ebp), %ebx
	movl	$1, %eax
	je	isBufferPosMacroBegin_reltrue_3
	movl	$0, %eax
isBufferPosMacroBegin_reltrue_3:
	testl	%eax, %eax
	jnz	isBufferPosMacroBegin_logexprtrue_1
	movl	$0, %eax
	jmp	isBufferPosMacroBegin_logexprfalse_1
isBufferPosMacroBegin_logexprtrue_1:
	movl	$1, %eax
isBufferPosMacroBegin_logexprfalse_1:
	testl	%eax, %eax
	jnz	isBufferPosMacroBegin_ifbl_0
	jmp	isBufferPosMacroBegin_elsebl_0
isBufferPosMacroBegin_ifbl_0:
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroBegin_ret
	jmp	isBufferPosMacroBegin_endif_0

isBufferPosMacroBegin_elsebl_0:

isBufferPosMacroBegin_endif_0:

	#debug: assignment: chr = buffer [ pos - 1 ] ; 
	movl	%ebp, %eax
	addl	$-13, %eax
	pushl	%eax
	pushl	16(%ebp)
	popl	%ebx
	subl	$1, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: if: CharacterStrCmp ( buffer , pos , 2 , "##" ) == 0 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	$symtab+0, 12(%esp)
	call	CharacterStrCmp
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	isBufferPosMacroBegin_reltrue_5
	movl	$0, %eax
isBufferPosMacroBegin_reltrue_5:
	testl	%eax, %eax
	jnz	isBufferPosMacroBegin_ifbl_4
	jmp	isBufferPosMacroBegin_elsebl_4
isBufferPosMacroBegin_ifbl_4:
	#debug: assignment: * offset = pos + 2 ; 
	movl	%ebp, %eax
	addl	$20, %eax
	movl	(%eax), %eax
	pushl	%eax
	pushl	16(%ebp)
	popl	%ebx
	addl	$2, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroBegin_ret
	jmp	isBufferPosMacroBegin_endif_4

isBufferPosMacroBegin_elsebl_4:

	#debug: if: isalnum ( chr . value ) == 0 && chr . value != '_' 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-13, %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	movl	%eax, 0(%esp)
	call	isalnum
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	isBufferPosMacroBegin_reltrue_8
	movl	$0, %eax
isBufferPosMacroBegin_reltrue_8:
	testl	%eax, %eax
	jz	isBufferPosMacroBegin_logtermfalse_7
	movl	%ebp, %eax
	addl	$-13, %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$95, %ebx
	movl	$1, %eax
	jne	isBufferPosMacroBegin_reltrue_9
	movl	$0, %eax
isBufferPosMacroBegin_reltrue_9:
	testl	%eax, %eax
	jz	isBufferPosMacroBegin_logtermfalse_7
	movl	$1, %eax
	jmp	isBufferPosMacroBegin_logtermtrue_7
isBufferPosMacroBegin_logtermfalse_7:
	movl	$0, %eax
isBufferPosMacroBegin_logtermtrue_7:
	testl	%eax, %eax
	jnz	isBufferPosMacroBegin_ifbl_6
	jmp	isBufferPosMacroBegin_elsebl_6
isBufferPosMacroBegin_ifbl_6:
	#debug: assignment: * offset = pos ; 
	movl	%ebp, %eax
	addl	$20, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroBegin_ret
	jmp	isBufferPosMacroBegin_endif_6

isBufferPosMacroBegin_elsebl_6:

isBufferPosMacroBegin_endif_6:

isBufferPosMacroBegin_endif_4:

	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	isBufferPosMacroBegin_ret


isBufferPosMacroBegin_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( Character * buffer , int buffer_length , int pos , int * offset ) 
.globl isBufferPosMacroEnd
.type isBufferPosMacroEnd, @function
isBufferPosMacroEnd:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$13, %esp


	#debug: if: pos > buffer_length 
	pushl	16(%ebp)
	popl	%ebx
	cmpl	12(%ebp), %ebx
	movl	$1, %eax
	jg	isBufferPosMacroEnd_reltrue_11
	movl	$0, %eax
isBufferPosMacroEnd_reltrue_11:
	testl	%eax, %eax
	jnz	isBufferPosMacroEnd_ifbl_10
	jmp	isBufferPosMacroEnd_elsebl_10
isBufferPosMacroEnd_ifbl_10:
	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	isBufferPosMacroEnd_ret
	jmp	isBufferPosMacroEnd_endif_10

isBufferPosMacroEnd_elsebl_10:

isBufferPosMacroEnd_endif_10:

	#debug: if: pos == buffer_length 
	pushl	16(%ebp)
	popl	%ebx
	cmpl	12(%ebp), %ebx
	movl	$1, %eax
	je	isBufferPosMacroEnd_reltrue_13
	movl	$0, %eax
isBufferPosMacroEnd_reltrue_13:
	testl	%eax, %eax
	jnz	isBufferPosMacroEnd_ifbl_12
	jmp	isBufferPosMacroEnd_elsebl_12
isBufferPosMacroEnd_ifbl_12:
	#debug: assignment: * offset = pos ; 
	movl	%ebp, %eax
	addl	$20, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroEnd_ret
	jmp	isBufferPosMacroEnd_endif_12

isBufferPosMacroEnd_elsebl_12:

isBufferPosMacroEnd_endif_12:

	#debug: assignment: chr = buffer [ pos ] ; 
	movl	%ebp, %eax
	addl	$-13, %eax
	pushl	%eax
	pushl	16(%ebp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: if: CharacterStrCmp ( buffer , pos , 2 , "##" ) == 0 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	$symtab+0, 12(%esp)
	call	CharacterStrCmp
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	isBufferPosMacroEnd_reltrue_15
	movl	$0, %eax
isBufferPosMacroEnd_reltrue_15:
	testl	%eax, %eax
	jnz	isBufferPosMacroEnd_ifbl_14
	jmp	isBufferPosMacroEnd_elsebl_14
isBufferPosMacroEnd_ifbl_14:
	#debug: assignment: * offset = pos + 2 ; 
	movl	%ebp, %eax
	addl	$20, %eax
	movl	(%eax), %eax
	pushl	%eax
	pushl	16(%ebp)
	popl	%ebx
	addl	$2, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroEnd_ret
	jmp	isBufferPosMacroEnd_endif_14

isBufferPosMacroEnd_elsebl_14:

	#debug: if: isalnum ( chr . value ) == 0 && chr . value != '_' 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-13, %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	movl	%eax, 0(%esp)
	call	isalnum
	addl	$4, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	isBufferPosMacroEnd_reltrue_18
	movl	$0, %eax
isBufferPosMacroEnd_reltrue_18:
	testl	%eax, %eax
	jz	isBufferPosMacroEnd_logtermfalse_17
	movl	%ebp, %eax
	addl	$-13, %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$95, %ebx
	movl	$1, %eax
	jne	isBufferPosMacroEnd_reltrue_19
	movl	$0, %eax
isBufferPosMacroEnd_reltrue_19:
	testl	%eax, %eax
	jz	isBufferPosMacroEnd_logtermfalse_17
	movl	$1, %eax
	jmp	isBufferPosMacroEnd_logtermtrue_17
isBufferPosMacroEnd_logtermfalse_17:
	movl	$0, %eax
isBufferPosMacroEnd_logtermtrue_17:
	testl	%eax, %eax
	jnz	isBufferPosMacroEnd_ifbl_16
	jmp	isBufferPosMacroEnd_elsebl_16
isBufferPosMacroEnd_ifbl_16:
	#debug: assignment: * offset = pos ; 
	movl	%ebp, %eax
	addl	$20, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return 1 ; 
	movl	$1, %eax
	jmp	isBufferPosMacroEnd_ret
	jmp	isBufferPosMacroEnd_endif_16

isBufferPosMacroEnd_elsebl_16:

isBufferPosMacroEnd_endif_16:

isBufferPosMacroEnd_endif_14:

	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	isBufferPosMacroEnd_ret


isBufferPosMacroEnd_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( preproc * instance , Character * next ) 
.globl setReplacementCharacter
.type setReplacementCharacter, @function
setReplacementCharacter:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$24, %esp


	#debug: assignment: next -> value = '\0' ; 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	pushl	%eax
	popl	%ebx
	movb	$0, (%ebx)
	#debug: if: instance -> replacement == 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20712, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_21
	movl	$0, %eax
setReplacementCharacter_reltrue_21:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_20
	jmp	setReplacementCharacter_elsebl_20
setReplacementCharacter_ifbl_20:
	#debug: return: return ; 
	jmp	setReplacementCharacter_ret
	jmp	setReplacementCharacter_endif_20

setReplacementCharacter_elsebl_20:

setReplacementCharacter_endif_20:

	#debug: assignment: replacement = instance -> replacement ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20712, %eax
	movl	(%eax), %eax
	movl	%eax, -20(%ebp)
	#debug: assignment: value = replacement -> value ; 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$832, %eax
	movl	(%eax), %eax
	movl	%eax, -24(%ebp)
	#debug: if: instance -> paramReplacement == 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_23
	movl	$0, %eax
setReplacementCharacter_reltrue_23:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_22
	jmp	setReplacementCharacter_elsebl_22
setReplacementCharacter_ifbl_22:
	#debug: assignment: param = Get_Front_Of_ParametersList ( & replacement -> parameters ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$840, %eax
	movl	%eax, 0(%esp)
	call	Get_Front_Of_ParametersList
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	#debug: while: param != 0 
setReplacementCharacter_while_24:
	pushl	-16(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	setReplacementCharacter_reltrue_25
	movl	$0, %eax
setReplacementCharacter_reltrue_25:
	testl	%eax, %eax
	jz	setReplacementCharacter_endwhile_24

	#debug: assignment: param_length = CharacterLen ( param -> name ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-16, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 0(%esp)
	call	CharacterLen
	addl	$4, %esp
	movl	%eax, -4(%ebp)
	#debug: assignment: start_pos = 0 ; 
	movl	$0, -8(%ebp)
	#debug: assignment: offset = 0 ; 
	movl	$0, -12(%ebp)
	#debug: if: isBufferPosMacroBegin ( value , replacement -> valueLength , instance -> replacementPos , & start_pos ) == 1 && isBufferPosMacroEnd ( value , replacement -> valueLength , start_pos + param_length , & offset ) == 1 
	subl	$16, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$836, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	%eax, 12(%esp)
	call	isBufferPosMacroBegin
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_28
	movl	$0, %eax
setReplacementCharacter_reltrue_28:
	testl	%eax, %eax
	jz	setReplacementCharacter_logtermfalse_27
	subl	$16, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$836, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	pushl	-8(%ebp)
	popl	%ebx
	addl	-4(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	%eax, 12(%esp)
	call	isBufferPosMacroEnd
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_29
	movl	$0, %eax
setReplacementCharacter_reltrue_29:
	testl	%eax, %eax
	jz	setReplacementCharacter_logtermfalse_27
	movl	$1, %eax
	jmp	setReplacementCharacter_logtermtrue_27
setReplacementCharacter_logtermfalse_27:
	movl	$0, %eax
setReplacementCharacter_logtermtrue_27:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_26
	jmp	setReplacementCharacter_elsebl_26
setReplacementCharacter_ifbl_26:
	#debug: if: CharacterSubCmp ( value , start_pos , param_length , param -> name ) == 0 
	subl	$16, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-16, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 12(%esp)
	call	CharacterSubCmp
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_31
	movl	$0, %eax
setReplacementCharacter_reltrue_31:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_30
	jmp	setReplacementCharacter_elsebl_30
setReplacementCharacter_ifbl_30:
	#debug: assignment: instance -> replacementPos = offset ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: instance -> paramReplacement = param -> replacement ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-16, %eax
	movl	(%eax), %eax
	addl	$832, %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: instance -> paramReplacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	jmp	setReplacementCharacter_endwhile_24
	jmp	setReplacementCharacter_endif_30

setReplacementCharacter_elsebl_30:

setReplacementCharacter_endif_30:

	jmp	setReplacementCharacter_endif_26

setReplacementCharacter_elsebl_26:

setReplacementCharacter_endif_26:

	#debug: assignment: param = Get_Next_In_ParametersList ( param ) ; 
	subl	$4, %esp
	movl	-16(%ebp), %eax
	movl	%eax, 0(%esp)
	call	Get_Next_In_ParametersList
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	jmp	setReplacementCharacter_while_24
setReplacementCharacter_endwhile_24:

	jmp	setReplacementCharacter_endif_22

setReplacementCharacter_elsebl_22:

setReplacementCharacter_endif_22:

	#debug: if: instance -> paramReplacement != 0 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	setReplacementCharacter_reltrue_33
	movl	$0, %eax
setReplacementCharacter_reltrue_33:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_32
	jmp	setReplacementCharacter_elsebl_32
setReplacementCharacter_ifbl_32:
	#debug: if: instance -> paramReplacementPos == CharacterLen ( instance -> paramReplacement ) 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	movl	(%eax), %eax
	pushl	%eax
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	movl	(%eax), %eax
	movl	%eax, 0(%esp)
	call	CharacterLen
	addl	$4, %esp
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_35
	movl	$0, %eax
setReplacementCharacter_reltrue_35:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_34
	jmp	setReplacementCharacter_elsebl_34
setReplacementCharacter_ifbl_34:
	#debug: assignment: instance -> paramReplacement = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> paramReplacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	jmp	setReplacementCharacter_endif_34

setReplacementCharacter_elsebl_34:

	#debug: assignment: * next = instance -> paramReplacement [ instance -> paramReplacementPos ] ; 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: assignment: instance -> paramReplacementPos = instance -> paramReplacementPos + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: return: return ; 
	jmp	setReplacementCharacter_ret
setReplacementCharacter_endif_34:

	jmp	setReplacementCharacter_endif_32

setReplacementCharacter_elsebl_32:

setReplacementCharacter_endif_32:

	#debug: if: instance -> replacementPos == replacement -> valueLength 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$836, %eax
	movl	(%eax), %eax
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	je	setReplacementCharacter_reltrue_37
	movl	$0, %eax
setReplacementCharacter_reltrue_37:
	testl	%eax, %eax
	jnz	setReplacementCharacter_ifbl_36
	jmp	setReplacementCharacter_elsebl_36
setReplacementCharacter_ifbl_36:
	#debug: assignment: instance -> replacement = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20712, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> replacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> paramReplacement = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20720, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	#debug: assignment: instance -> paramReplacementPos = 0 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20724, %eax
	pushl	%eax
	popl	%ebx
	movl	$0, (%ebx)
	jmp	setReplacementCharacter_endif_36

setReplacementCharacter_elsebl_36:

	#debug: assignment: * next = value [ instance -> replacementPos ] ; 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: assignment: instance -> replacementPos = instance -> replacementPos + 1 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20716, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
setReplacementCharacter_endif_36:



setReplacementCharacter_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( preproc * instance , Character * next ) 
.globl substage_getNext
.type substage_getNext, @function
substage_getNext:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$53, %esp


	#debug: func-call: setReplacementCharacter ( instance , next ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	setReplacementCharacter
	addl	$8, %esp
	#debug: while: next -> value == '\0' 
substage_getNext_while_38:
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_39
	movl	$0, %eax
substage_getNext_reltrue_39:
	testl	%eax, %eax
	jz	substage_getNext_endwhile_38

	#debug: assignment: line = & instance -> substage ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$14036, %eax
	movl	%eax, -40(%ebp)
	#debug: if: line -> pos >= line -> length 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6656, %eax
	movl	(%eax), %eax
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	jge	substage_getNext_reltrue_41
	movl	$0, %eax
substage_getNext_reltrue_41:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_40
	jmp	substage_getNext_elsebl_40
substage_getNext_ifbl_40:
	#debug: assignment: result = getNextLine ( instance , 3 , & instance -> substage ) ; 
	subl	$12, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$3, 4(%esp)
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$14036, %eax
	movl	%eax, 8(%esp)
	call	getNextLine
	addl	$12, %esp
	movl	%eax, -4(%ebp)
	#debug: if: result != 0 
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_43
	movl	$0, %eax
substage_getNext_reltrue_43:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_42
	jmp	substage_getNext_elsebl_42
substage_getNext_ifbl_42:
	#debug: return: return result ; 
	movl	-4(%ebp), %eax
	jmp	substage_getNext_ret
	jmp	substage_getNext_endif_42

substage_getNext_elsebl_42:

substage_getNext_endif_42:

	jmp	substage_getNext_endif_40

substage_getNext_elsebl_40:

substage_getNext_endif_40:

	#debug: func-call: updateLineProperties ( line ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	updateLineProperties
	addl	$4, %esp
	#debug: if: line -> skip == 0 && line -> posInString == 0 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6672, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_46
	movl	$0, %eax
substage_getNext_reltrue_46:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_45
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6664, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_47
	movl	$0, %eax
substage_getNext_reltrue_47:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_45
	movl	$1, %eax
	jmp	substage_getNext_logtermtrue_45
substage_getNext_logtermfalse_45:
	movl	$0, %eax
substage_getNext_logtermtrue_45:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_44
	jmp	substage_getNext_elsebl_44
substage_getNext_ifbl_44:
	#debug: assignment: node = Get_Front_Of_DefinesList ( & instance -> definesList ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$13944, %eax
	movl	%eax, 0(%esp)
	call	Get_Front_Of_DefinesList
	addl	$4, %esp
	movl	%eax, -20(%ebp)
	#debug: while: node != 0 
substage_getNext_while_48:
	pushl	-20(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_49
	movl	$0, %eax
substage_getNext_reltrue_49:
	testl	%eax, %eax
	jz	substage_getNext_endwhile_48

	#debug: assignment: macro_length = CharacterLen ( node -> name ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 0(%esp)
	call	CharacterLen
	addl	$4, %esp
	movl	%eax, -16(%ebp)
	#debug: assignment: start_pos = 0 ; 
	movl	$0, -8(%ebp)
	#debug: assignment: offset = 0 ; 
	movl	$0, -12(%ebp)
	#debug: if: isBufferPosMacroBegin ( line -> buffer , line -> length , line -> pos , & start_pos ) == 1 && isBufferPosMacroEnd ( line -> buffer , line -> length , start_pos + macro_length , & offset ) == 1 
	subl	$16, %esp
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6656, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	%eax, 12(%esp)
	call	isBufferPosMacroBegin
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_52
	movl	$0, %eax
substage_getNext_reltrue_52:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_51
	subl	$16, %esp
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6656, %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	pushl	-8(%ebp)
	popl	%ebx
	addl	-16(%ebp), %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-12, %eax
	movl	%eax, 12(%esp)
	call	isBufferPosMacroEnd
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_53
	movl	$0, %eax
substage_getNext_reltrue_53:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_51
	movl	$1, %eax
	jmp	substage_getNext_logtermtrue_51
substage_getNext_logtermfalse_51:
	movl	$0, %eax
substage_getNext_logtermtrue_51:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_50
	jmp	substage_getNext_elsebl_50
substage_getNext_ifbl_50:
	#debug: if: CharacterSubCmp ( line -> buffer , start_pos , macro_length , node -> name ) == 0 
	subl	$16, %esp
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 0(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 12(%esp)
	call	CharacterSubCmp
	addl	$16, %esp
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_55
	movl	$0, %eax
substage_getNext_reltrue_55:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_54
	jmp	substage_getNext_elsebl_54
substage_getNext_ifbl_54:
	#debug: assignment: line -> pos = offset ; 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: if: line -> pos > line -> length 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6656, %eax
	movl	(%eax), %eax
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	jg	substage_getNext_reltrue_57
	movl	$0, %eax
substage_getNext_reltrue_57:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_56
	jmp	substage_getNext_elsebl_56
substage_getNext_ifbl_56:
	jmp	substage_getNext_while_48
	jmp	substage_getNext_endif_56

substage_getNext_elsebl_56:

substage_getNext_endif_56:

	#debug: assignment: offset = line -> pos ; 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	movl	%eax, -12(%ebp)
	#debug: func-call: disposeWhitespace ( line ) 
	subl	$4, %esp
	movl	-40(%ebp), %eax
	movl	%eax, 0(%esp)
	call	disposeWhitespace
	addl	$4, %esp
	#debug: assignment: chr = line -> buffer [ line -> pos ] ; 
	movl	%ebp, %eax
	addl	$-53, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: if: Is_ParametersList_Empty ( & node -> parameters ) || chr . value != '(' 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$840, %eax
	movl	%eax, 0(%esp)
	call	Is_ParametersList_Empty
	addl	$4, %esp
	testl	%eax, %eax
	jnz	substage_getNext_logexprtrue_59
	movl	%ebp, %eax
	addl	$-53, %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$40, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_60
	movl	$0, %eax
substage_getNext_reltrue_60:
	testl	%eax, %eax
	jnz	substage_getNext_logexprtrue_59
	movl	$0, %eax
	jmp	substage_getNext_logexprfalse_59
substage_getNext_logexprtrue_59:
	movl	$1, %eax
substage_getNext_logexprfalse_59:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_58
	jmp	substage_getNext_elsebl_58
substage_getNext_ifbl_58:
	#debug: assignment: line -> pos = offset ; 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	jmp	substage_getNext_endif_58

substage_getNext_elsebl_58:

	#debug: func-call: memset ( & replace_param , 0 , sizeof ( ParametersList ) ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-36, %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	movl	$8, 8(%esp)
	call	memset
	addl	$12, %esp
	#debug: assignment: result = parseParametersList ( instance , & replace_param , line , 0 ) ; 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-36, %eax
	movl	%eax, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$0, 12(%esp)
	call	parseParametersList
	addl	$16, %esp
	movl	%eax, -4(%ebp)
	#debug: if: result != 0 
	pushl	-4(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_62
	movl	$0, %eax
substage_getNext_reltrue_62:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_61
	jmp	substage_getNext_elsebl_61
substage_getNext_ifbl_61:
	#debug: func-call: preproc_reportError ( instance , "Missformed macro (::parameters list::) call found" , line , 2 ) 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+3, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$2, 12(%esp)
	call	preproc_reportError
	addl	$16, %esp
	#debug: func-call: exit ( 1 ) 
	subl	$4, %esp
	movl	$1, 0(%esp)
	call	exit
	addl	$4, %esp
	jmp	substage_getNext_endif_61

substage_getNext_elsebl_61:

substage_getNext_endif_61:

	#debug: assignment: orig_param = Get_Front_Of_ParametersList ( & node -> parameters ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$840, %eax
	movl	%eax, 0(%esp)
	call	Get_Front_Of_ParametersList
	addl	$4, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: cpy_param = Get_Front_Of_ParametersList ( & replace_param ) ; 
	subl	$4, %esp
	movl	%ebp, %eax
	addl	$-36, %eax
	movl	%eax, 0(%esp)
	call	Get_Front_Of_ParametersList
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	#debug: while: orig_param != 0 && cpy_param != 0 
substage_getNext_while_63:
	pushl	-24(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_65
	movl	$0, %eax
substage_getNext_reltrue_65:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_64
	pushl	-28(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_66
	movl	$0, %eax
substage_getNext_reltrue_66:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_64
	movl	$1, %eax
	jmp	substage_getNext_logtermtrue_64
substage_getNext_logtermfalse_64:
	movl	$0, %eax
substage_getNext_logtermtrue_64:
	testl	%eax, %eax
	jz	substage_getNext_endwhile_63

	#debug: func-call: memset ( orig_param -> replacement , 0 , sizeof ( Character ) * 64 ) 
	subl	$12, %esp
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$832, %eax
	movl	%eax, 0(%esp)
	movl	$0, 4(%esp)
	pushl	$13
	popl	%ebx
	imull	$64, %ebx
	pushl	%ebx
	popl	%eax
	movl	%eax, 8(%esp)
	call	memset
	addl	$12, %esp
	#debug: func-call: CharacterCpy ( orig_param -> replacement , cpy_param -> name ) 
	subl	$8, %esp
	movl	%ebp, %eax
	addl	$-24, %eax
	movl	(%eax), %eax
	addl	$832, %eax
	movl	%eax, 0(%esp)
	movl	%ebp, %eax
	addl	$-28, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movl	%eax, 4(%esp)
	call	CharacterCpy
	addl	$8, %esp
	#debug: assignment: orig_param = Get_Next_In_ParametersList ( orig_param ) ; 
	subl	$4, %esp
	movl	-24(%ebp), %eax
	movl	%eax, 0(%esp)
	call	Get_Next_In_ParametersList
	addl	$4, %esp
	movl	%eax, -24(%ebp)
	#debug: assignment: cpy_param = Get_Next_In_ParametersList ( cpy_param ) ; 
	subl	$4, %esp
	movl	-28(%ebp), %eax
	movl	%eax, 0(%esp)
	call	Get_Next_In_ParametersList
	addl	$4, %esp
	movl	%eax, -28(%ebp)
	jmp	substage_getNext_while_63
substage_getNext_endwhile_63:

	#debug: if: orig_param != 0 || cpy_param != 0 
	pushl	-24(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_69
	movl	$0, %eax
substage_getNext_reltrue_69:
	testl	%eax, %eax
	jnz	substage_getNext_logexprtrue_68
	pushl	-28(%ebp)
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jne	substage_getNext_reltrue_70
	movl	$0, %eax
substage_getNext_reltrue_70:
	testl	%eax, %eax
	jnz	substage_getNext_logexprtrue_68
	movl	$0, %eax
	jmp	substage_getNext_logexprfalse_68
substage_getNext_logexprtrue_68:
	movl	$1, %eax
substage_getNext_logexprfalse_68:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_67
	jmp	substage_getNext_elsebl_67
substage_getNext_ifbl_67:
	#debug: func-call: preproc_reportError ( instance , "Missformed macro (::parameters count::) call found" , line , 2 ) 
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	$symtab+53, 4(%esp)
	movl	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$2, 12(%esp)
	call	preproc_reportError
	addl	$16, %esp
	#debug: func-call: exit ( 1 ) 
	subl	$4, %esp
	movl	$1, 0(%esp)
	call	exit
	addl	$4, %esp
	jmp	substage_getNext_endif_67

substage_getNext_elsebl_67:

substage_getNext_endif_67:

substage_getNext_endif_58:

	#debug: if: node -> valueLength > 0 
	movl	%ebp, %eax
	addl	$-20, %eax
	movl	(%eax), %eax
	addl	$836, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	jg	substage_getNext_reltrue_72
	movl	$0, %eax
substage_getNext_reltrue_72:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_71
	jmp	substage_getNext_elsebl_71
substage_getNext_ifbl_71:
	#debug: assignment: instance -> replacement = node ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	(%eax), %eax
	addl	$20712, %eax
	pushl	%eax
	movl	-20(%ebp), %eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: func-call: setReplacementCharacter ( instance , next ) 
	subl	$8, %esp
	movl	8(%ebp), %eax
	movl	%eax, 0(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	call	setReplacementCharacter
	addl	$8, %esp
	jmp	substage_getNext_endif_71

substage_getNext_elsebl_71:

substage_getNext_endif_71:

	jmp	substage_getNext_endif_54

substage_getNext_elsebl_54:

substage_getNext_endif_54:

	jmp	substage_getNext_endif_50

substage_getNext_elsebl_50:

substage_getNext_endif_50:

	#debug: assignment: node = Get_Next_In_DefinesList ( node ) ; 
	subl	$4, %esp
	movl	-20(%ebp), %eax
	movl	%eax, 0(%esp)
	call	Get_Next_In_DefinesList
	addl	$4, %esp
	movl	%eax, -20(%ebp)
	jmp	substage_getNext_while_48
substage_getNext_endwhile_48:

	jmp	substage_getNext_endif_44

substage_getNext_elsebl_44:

substage_getNext_endif_44:

	#debug: if: next -> value == '\0' && line -> pos <= line -> length 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	movb	(%eax), %al
	movsbl	%al, %eax
	pushl	%eax
	popl	%ebx
	cmpl	$0, %ebx
	movl	$1, %eax
	je	substage_getNext_reltrue_75
	movl	$0, %eax
substage_getNext_reltrue_75:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_74
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6656, %eax
	movl	(%eax), %eax
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	jle	substage_getNext_reltrue_76
	movl	$0, %eax
substage_getNext_reltrue_76:
	testl	%eax, %eax
	jz	substage_getNext_logtermfalse_74
	movl	$1, %eax
	jmp	substage_getNext_logtermtrue_74
substage_getNext_logtermfalse_74:
	movl	$0, %eax
substage_getNext_logtermtrue_74:
	testl	%eax, %eax
	jnz	substage_getNext_ifbl_73
	jmp	substage_getNext_elsebl_73
substage_getNext_ifbl_73:
	#debug: assignment: * next = line -> buffer [ line -> pos ] ; 
	movl	%ebp, %eax
	addl	$12, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$0, %eax
	popl	%esi
	imull	$13, %esi
	addl	%esi, %eax
	popl	%ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movl	(%eax), %ecx
	movl	%ecx, (%ebx)
	addl	$4, %eax
	addl	$4, %ebx
	movb	(%eax), %cl
	movb	%cl, (%ebx)
	addl	$1, %eax
	addl	$1, %ebx
	#debug: assignment: line -> pos = line -> pos + 1 ; 
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-40, %eax
	movl	(%eax), %eax
	addl	$6660, %eax
	movl	(%eax), %eax
	pushl	%eax
	popl	%ebx
	addl	$1, %ebx
	pushl	%ebx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	jmp	substage_getNext_endif_73

substage_getNext_elsebl_73:

substage_getNext_endif_73:

	jmp	substage_getNext_while_38
substage_getNext_endwhile_38:

	#debug: return: return 0 ; 
	movl	$0, %eax
	jmp	substage_getNext_ret


substage_getNext_ret:
	movl	%ebp, %esp
	popl	%ebp
	ret




# The symbol table 

.section .data
symtab:
	.string	"##"
	.string	"Missformed macro (::parameters list::) call found"
	.string	"Missformed macro (::parameters count::) call found"

