# linked executable code generated by HRWCC

.section .text

call 218
	#debug: func-def: ( int var1 , int var2 ) 
.type euklidggt, @function
# euklidggt: [@1]
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp


	#debug: if: var1 < var2 && var2 > var1 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	pushl	%eax
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	jl	16
	movl	$0, %eax
# euklidggt_reltrue_2: [@16]
	testl	%eax, %eax
	jz	34
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	popl	%ebx
	cmpl	%eax, %ebx
	movl	$1, %eax
	jg	30
	movl	$0, %eax
# euklidggt_reltrue_3: [@30]
	testl	%eax, %eax
	jz	34
	movl	$1, %eax
	jmp	35
# euklidggt_logtermfalse_1: [@34]
	movl	$0, %eax
# euklidggt_logtermtrue_1: [@35]
	testl	%eax, %eax
	jnz	38
	jmp	63
# euklidggt_ifbl_0: [@38]
	#debug: assignment: div = var1 ; 
	movl	%ebp, %eax
	addl	$-4, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: var1 = var2 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: var2 = div ; 
	movl	%ebp, %eax
	addl	$12, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-4, %eax
	movl	
	popl	%ebx
	movl	%eax, (%ebx)
	jmp	63

# euklidggt_elsebl_0: [@63]

# euklidggt_endif_0: [@63]

	#debug: while: var2 > 1 || 0 
# euklidggt_while_4: [@63]
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	pushl	%eax
	popl	%ebx
	cmpl	$1, %ebx
	movl	$1, %eax
	jg	72
	movl	$0, %eax
# euklidggt_reltrue_6: [@72]
	testl	%eax, %eax
	jnz	79
	movl	$0, %eax
	testl	%eax, %eax
	jnz	79
	movl	$0, %eax
	jmp	80
# euklidggt_logexprtrue_5: [@79]
	movl	$1, %eax
# euklidggt_logexprfalse_5: [@80]
	testl	%eax, %eax
	jz	135

	#debug: assignment: div = var1 / var2 ; 
	movl	%ebp, %eax
	addl	$-4, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	pushl	%eax
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: mod = var1 % var2 ; 
	movl	%ebp, %eax
	addl	$-8, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	pushl	%eax
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%edx
	popl	%eax
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: var1 = var2 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$12, %eax
	movl	
	popl	%ebx
	movl	%eax, (%ebx)
	#debug: assignment: var2 = mod ; 
	movl	%ebp, %eax
	addl	$12, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$-8, %eax
	movl	
	popl	%ebx
	movl	%eax, (%ebx)
	jmp	63
# euklidggt_endwhile_4: [@135]

	#debug: return: return var1 * 1 + ( 6 % 2 ) + 2 / 4 ; 
	movl	%ebp, %eax
	addl	$8, %eax
	movl	
	pushl	%eax
	popl	%ebx
	imull	$1, %ebx
	pushl	%ebx
	popl	%eax
	pushl	%eax
	pushl	$6
	movl	$2, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%edx
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	pushl	$2
	movl	$4, %eax
	movl	%eax, %ebx
	popl	%eax
	movl	$0, %edx
	idivl	%ebx
	pushl	%eax
	popl	%eax
	popl	%ebx
	addl	%eax, %ebx
	pushl	%ebx
	popl	%eax
	jmp	168


# euklidggt_ret: [@168]
	movl	%ebp, %esp
	popl	%ebp
	ret




	#debug: func-def: ( char ch ) 
.type test, @function
# test: [@171]
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp


	#debug: assignment: text [ 0 ] = ch ; 
	pushl	$0
	movl	%ebp, %eax
	addl	$-4, %eax
	popl	%esi
	addl	%esi, %eax
	pushl	%eax
	movl	%ebp, %eax
	addl	$8, %eax
	movb	
	popl	%ebx
	movb	%al, (%ebx)
	#debug: assignment: text [ 1 ] = '\n' ; 
	pushl	$1
	movl	%ebp, %eax
	addl	$-4, %eax
	popl	%esi
	addl	%esi, %eax
	pushl	%eax
	popl	%ebx
	movb	$13, (%ebx)
	#debug: assignment: text [ 2 ] = '\0' ; 
	pushl	$2
	movl	%ebp, %eax
	addl	$-4, %eax
	popl	%esi
	addl	%esi, %eax
	pushl	%eax
	popl	%ebx
	movb	$0, (%ebx)
	#debug: func-call: puts ( "hello\n" ) 
	subl	$4, %esp
	movl	$symtab+0, 0(%esp)
